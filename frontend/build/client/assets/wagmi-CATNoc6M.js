import{t as M,F as J,H as W,B as ie,G as oe,J as se,R as ce,K as ee,L as U,N as K,O as F,P as Z,U as A,V as ae,X as x,Y as z,Z as ue}from"./index-BoWXTe0l.js";import{E as de}from"./index-LOB-adgA.js";function le(s){const e={formatters:void 0,fees:void 0,serializers:void 0,...s};function o(u){return n=>{const r=typeof n=="function"?n(u):n,f={...u,...r};return Object.assign(f,{extend:o(f)})}}return Object.assign(e,{extend:o(e)})}function te(s,{errorInstance:e=new Error("timed out"),timeout:o,signal:u}){return new Promise((n,r)=>{(async()=>{let f;try{const h=new AbortController;o>0&&(f=setTimeout(()=>{u?h.abort():r(e)},o)),n(await s({signal:h?.signal||null}))}catch(h){h?.name==="AbortError"&&r(e),r(h)}finally{clearTimeout(f)}})()})}function fe(){return{current:0,take(){return this.current++},reset(){this.current=0}}}const G=fe();function he(s,e={}){const{url:o,headers:u}=me(s);return{async request(n){const{body:r,fetchFn:f=e.fetchFn??fetch,onRequest:h=e.onRequest,onResponse:a=e.onResponse,timeout:t=e.timeout??1e4}=n,m={...e.fetchOptions??{},...n.fetchOptions??{}},{headers:b,method:w,signal:v}=m;try{const p=await te(async({signal:g})=>{const P={...m,body:Array.isArray(r)?M(r.map(i=>({jsonrpc:"2.0",id:i.id??G.take(),...i}))):M({jsonrpc:"2.0",id:r.id??G.take(),...r}),headers:{...u,"Content-Type":"application/json",...b},method:w||"POST",signal:v||(t>0?g:null)},I=new Request(o,P),S=await h?.(I,P)??{...P,url:o};return await f(S.url??o,S)},{errorInstance:new J({body:r,url:o}),timeout:t,signal:!0});a&&await a(p);let c;if(p.headers.get("Content-Type")?.startsWith("application/json"))c=await p.json();else{c=await p.text();try{c=JSON.parse(c||"{}")}catch(g){if(p.ok)throw g;c={error:c}}}if(!p.ok)throw new W({body:r,details:M(c.error)||p.statusText,headers:p.headers,status:p.status,url:o});return c}catch(p){throw p instanceof W||p instanceof J?p:new W({body:r,cause:p,url:o})}}}}function me(s){try{const e=new URL(s),o=(()=>{if(e.username){const u=`${decodeURIComponent(e.username)}:${decodeURIComponent(e.password)}`;return e.username="",e.password="",{url:e.toString(),headers:{Authorization:`Basic ${btoa(u)}`}}}})();return{url:e.toString(),...o}}catch{return{url:s}}}class pe extends ie{constructor(){super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.",{docsPath:"/docs/clients/intro",name:"UrlRequiredError"})}}function ge(s,e={}){const{batch:o,fetchFn:u,fetchOptions:n,key:r="http",methods:f,name:h="HTTP JSON-RPC",onFetchRequest:a,onFetchResponse:t,retryDelay:m,raw:b}=e;return({chain:w,retryCount:v,timeout:p})=>{const{batchSize:c=1e3,wait:g=0}=typeof o=="object"?o:{},P=e.retryCount??v,I=p??e.timeout??1e4,S=w?.rpcUrls.default.http[0];if(!S)throw new pe;const R=he(S,{fetchFn:u,fetchOptions:n,onRequest:a,onResponse:t,timeout:I});return oe({key:r,methods:f,name:h,async request({method:i,params:l}){const d={method:i,params:l},{schedule:C}=se({id:S,wait:g,shouldSplitBatch(k){return k.length>c},fn:k=>R.request({body:k}),sort:(k,_)=>k.id-_.id}),y=async k=>o?C(k):[await R.request({body:k})],[{error:E,result:j}]=await y(d);if(b)return{error:E,result:j};if(E)throw new ce({body:d,error:E,url:S});return j},retryCount:P,retryDelay:m,timeout:I,type:"http"},{fetchOptions:n,url:S})}}class O extends ee{constructor(){super("Provider not found."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ProviderNotFoundError"})}}class Me extends ee{constructor({connector:e}){super(`"${e.name}" does not support programmatic chain switching.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SwitchChainNotSupportedError"})}}D.type="injected";function D(s={}){const{shimDisconnect:e=!0,unstable_shimAsyncInject:o}=s;function u(){const a=s.target;if(typeof a=="function"){const t=a();if(t)return t}return typeof a=="object"?a:typeof a=="string"?{...we[a]??{id:a,name:`${a[0].toUpperCase()}${a.slice(1)}`,provider:`is${a[0].toUpperCase()}${a.slice(1)}`}}:{id:"injected",name:"Injected",provider(t){return t?.ethereum}}}let n,r,f,h;return a=>({get icon(){return u().icon},get id(){return u().id},get name(){return u().name},type:D.type,async setup(){const t=await this.getProvider();t?.on&&s.target&&(f||(f=this.onConnect.bind(this),t.on("connect",f)),n||(n=this.onAccountsChanged.bind(this),t.on("accountsChanged",n)))},async connect({chainId:t,isReconnecting:m,withCapabilities:b}={}){const w=await this.getProvider();if(!w)throw new O;let v=[];if(m)v=await this.getAccounts().catch(()=>[]);else if(e)try{v=(await w.request({method:"wallet_requestPermissions",params:[{eth_accounts:{}}]}))[0]?.caveats?.[0]?.value?.map(c=>U(c)),v.length>0&&(v=await this.getAccounts())}catch(p){const c=p;if(c.code===A.code)throw new A(c);if(c.code===x.code)throw c}try{!v?.length&&!m&&(v=(await w.request({method:"eth_requestAccounts"})).map(g=>U(g))),f&&(w.removeListener("connect",f),f=void 0),n||(n=this.onAccountsChanged.bind(this),w.on("accountsChanged",n)),r||(r=this.onChainChanged.bind(this),w.on("chainChanged",r)),h||(h=this.onDisconnect.bind(this),w.on("disconnect",h));let p=await this.getChainId();return t&&p!==t&&(p=(await this.switchChain({chainId:t}).catch(g=>{if(g.code===A.code)throw g;return{id:p}}))?.id??p),e&&await a.storage?.removeItem(`${this.id}.disconnected`),s.target||await a.storage?.setItem("injected.connected",!0),{accounts:b?v.map(c=>({address:c,capabilities:{}})):v,chainId:p}}catch(p){const c=p;throw c.code===A.code?new A(c):c.code===x.code?new x(c):c}},async disconnect(){const t=await this.getProvider();if(!t)throw new O;r&&(t.removeListener("chainChanged",r),r=void 0),h&&(t.removeListener("disconnect",h),h=void 0),f||(f=this.onConnect.bind(this),t.on("connect",f));try{await te(()=>t.request({method:"wallet_revokePermissions",params:[{eth_accounts:{}}]}),{timeout:100})}catch{}e&&await a.storage?.setItem(`${this.id}.disconnected`,!0),s.target||await a.storage?.removeItem("injected.connected")},async getAccounts(){const t=await this.getProvider();if(!t)throw new O;return(await t.request({method:"eth_accounts"})).map(b=>U(b))},async getChainId(){const t=await this.getProvider();if(!t)throw new O;const m=await t.request({method:"eth_chainId"});return Number(m)},async getProvider(){if(typeof window>"u")return;let t;const m=u();return typeof m.provider=="function"?t=m.provider(window):typeof m.provider=="string"?t=N(window,m.provider):t=m.provider,t&&!t.removeListener&&("off"in t&&typeof t.off=="function"?t.removeListener=t.off:t.removeListener=()=>{}),t},async isAuthorized(){try{if(e&&await a.storage?.getItem(`${this.id}.disconnected`)||!s.target&&!await a.storage?.getItem("injected.connected"))return!1;if(!await this.getProvider()){if(o!==void 0&&o!==!1){const w=async()=>(typeof window<"u"&&window.removeEventListener("ethereum#initialized",w),!!await this.getProvider()),v=typeof o=="number"?o:1e3;if(await Promise.race([...typeof window<"u"?[new Promise(c=>window.addEventListener("ethereum#initialized",()=>c(w()),{once:!0}))]:[],new Promise(c=>setTimeout(()=>c(w()),v))]))return!0}throw new O}return!!(await ae(()=>this.getAccounts())).length}catch{return!1}},async switchChain({addEthereumChainParameter:t,chainId:m}){const b=await this.getProvider();if(!b)throw new O;const w=a.chains.find(p=>p.id===m);if(!w)throw new K(new F);const v=new Promise(p=>{const c=(g=>{"chainId"in g&&g.chainId===m&&(a.emitter.off("change",c),p())});a.emitter.on("change",c)});try{return await Promise.all([b.request({method:"wallet_switchEthereumChain",params:[{chainId:Z(m)}]}).then(async()=>{await this.getChainId()===m&&a.emitter.emit("change",{chainId:m})}),v]),w}catch(p){const c=p;if(c.code===4902||c?.data?.originalError?.code===4902)try{const{default:g,...P}=w.blockExplorers??{};let I;t?.blockExplorerUrls?I=t.blockExplorerUrls:g&&(I=[g.url,...Object.values(P).map(i=>i.url)]);let S;t?.rpcUrls?.length?S=t.rpcUrls:S=[w.rpcUrls.default?.http[0]??""];const R={blockExplorerUrls:I,chainId:Z(m),chainName:t?.chainName??w.name,iconUrls:t?.iconUrls,nativeCurrency:t?.nativeCurrency??w.nativeCurrency,rpcUrls:S};return await Promise.all([b.request({method:"wallet_addEthereumChain",params:[R]}).then(async()=>{if(await this.getChainId()===m)a.emitter.emit("change",{chainId:m});else throw new A(new Error("User rejected switch after adding network."))}),v]),w}catch(g){throw new A(g)}throw c.code===A.code?new A(c):new K(c)}},async onAccountsChanged(t){if(t.length===0)this.onDisconnect();else if(a.emitter.listenerCount("connect")){const m=(await this.getChainId()).toString();this.onConnect({chainId:m}),e&&await a.storage?.removeItem(`${this.id}.disconnected`)}else a.emitter.emit("change",{accounts:t.map(m=>U(m))})},onChainChanged(t){const m=Number(t);a.emitter.emit("change",{chainId:m})},async onConnect(t){const m=await this.getAccounts();if(m.length===0)return;const b=Number(t.chainId);a.emitter.emit("connect",{accounts:m,chainId:b});const w=await this.getProvider();w&&(f&&(w.removeListener("connect",f),f=void 0),n||(n=this.onAccountsChanged.bind(this),w.on("accountsChanged",n)),r||(r=this.onChainChanged.bind(this),w.on("chainChanged",r)),h||(h=this.onDisconnect.bind(this),w.on("disconnect",h)))},async onDisconnect(t){const m=await this.getProvider();t&&t.code===1013&&m&&(await this.getAccounts()).length||(a.emitter.emit("disconnect"),m&&(r&&(m.removeListener("chainChanged",r),r=void 0),h&&(m.removeListener("disconnect",h),h=void 0),f||(f=this.onConnect.bind(this),m.on("connect",f))))}})}const we={coinbaseWallet:{id:"coinbaseWallet",name:"Coinbase Wallet",provider(s){return s?.coinbaseWalletExtension?s.coinbaseWalletExtension:N(s,"isCoinbaseWallet")}},metaMask:{id:"metaMask",name:"MetaMask",provider(s){return N(s,e=>{if(!e.isMetaMask||e.isBraveWallet&&!e._events&&!e._state)return!1;const o=["isApexWallet","isAvalanche","isBitKeep","isBlockWallet","isKuCoinWallet","isMathWallet","isOkxWallet","isOKExWallet","isOneInchIOSWallet","isOneInchAndroidWallet","isOpera","isPhantom","isPortal","isRabby","isTokenPocket","isTokenary","isUniswapWallet","isZerion"];for(const u of o)if(e[u])return!1;return!0})}},phantom:{id:"phantom",name:"Phantom",provider(s){return s?.phantom?.ethereum?s.phantom?.ethereum:N(s,"isPhantom")}}};function N(s,e){function o(n){return typeof e=="function"?e(n):typeof e=="string"?n[e]:!0}const u=s.ethereum;if(u?.providers)return u.providers.find(n=>o(n));if(u&&o(u))return u}function ye(s){if(typeof window>"u")return;const e=o=>s(o.detail);return window.addEventListener("eip6963:announceProvider",e),window.dispatchEvent(new CustomEvent("eip6963:requestProvider")),()=>window.removeEventListener("eip6963:announceProvider",e)}function ve(){const s=new Set;let e=[];const o=()=>ye(n=>{e.some(({info:r})=>r.uuid===n.info.uuid)||(e=[...e,n],s.forEach(r=>r(e,{added:[n]})))});let u=o();return{_listeners(){return s},clear(){s.forEach(n=>n([],{removed:[...e]})),e=[]},destroy(){this.clear(),s.clear(),u?.()},findProvider({rdns:n}){return e.find(r=>r.info.rdns===n)},getProviders(){return e},reset(){this.clear(),u?.(),u=o()},subscribe(n,{emitImmediately:r}={}){return s.add(n),r&&n(e,{added:e}),()=>s.delete(n)}}}const be=s=>(e,o,u)=>{const n=u.subscribe;return u.subscribe=(f,h,a)=>{let t=f;if(h){const m=a?.equalityFn||Object.is;let b=f(u.getState());t=w=>{const v=f(w);if(!m(b,v)){const p=b;h(b=v,p)}},a?.fireImmediately&&h(b,b)}return n(t)},s(e,o,u)},Ce=be;function Ie(s,e){let o;try{o=s()}catch{return}return{getItem:n=>{var r;const f=a=>a===null?null:JSON.parse(a,void 0),h=(r=o.getItem(n))!=null?r:null;return h instanceof Promise?h.then(f):f(h)},setItem:(n,r)=>o.setItem(n,JSON.stringify(r,void 0)),removeItem:n=>o.removeItem(n)}}const H=s=>e=>{try{const o=s(e);return o instanceof Promise?o:{then(u){return H(u)(o)},catch(u){return this}}}catch(o){return{then(u){return this},catch(u){return H(u)(o)}}}},Se=(s,e)=>(o,u,n)=>{let r={storage:Ie(()=>localStorage),partialize:c=>c,version:0,merge:(c,g)=>({...g,...c}),...e},f=!1;const h=new Set,a=new Set;let t=r.storage;if(!t)return s((...c)=>{console.warn(`[zustand persist middleware] Unable to update item '${r.name}', the given storage is currently unavailable.`),o(...c)},u,n);const m=()=>{const c=r.partialize({...u()});return t.setItem(r.name,{state:c,version:r.version})},b=n.setState;n.setState=(c,g)=>{b(c,g),m()};const w=s((...c)=>{o(...c),m()},u,n);n.getInitialState=()=>w;let v;const p=()=>{var c,g;if(!t)return;f=!1,h.forEach(I=>{var S;return I((S=u())!=null?S:w)});const P=((g=r.onRehydrateStorage)==null?void 0:g.call(r,(c=u())!=null?c:w))||void 0;return H(t.getItem.bind(t))(r.name).then(I=>{if(I)if(typeof I.version=="number"&&I.version!==r.version){if(r.migrate)return[!0,r.migrate(I.state,I.version)];console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,I.state];return[!1,void 0]}).then(I=>{var S;const[R,i]=I;if(v=r.merge(i,(S=u())!=null?S:w),o(v,!0),R)return m()}).then(()=>{P?.(v,void 0),v=u(),f=!0,a.forEach(I=>I(v))}).catch(I=>{P?.(void 0,I)})};return n.persist={setOptions:c=>{r={...r,...c},c.storage&&(t=c.storage)},clearStorage:()=>{t?.removeItem(r.name)},getOptions:()=>r,rehydrate:()=>p(),hasHydrated:()=>f,onHydrate:c=>(h.add(c),()=>{h.delete(c)}),onFinishHydration:c=>(a.add(c),()=>{a.delete(c)})},r.skipHydration||p(),v||w},Pe=Se,V=s=>{let e;const o=new Set,u=(t,m)=>{const b=typeof t=="function"?t(e):t;if(!Object.is(b,e)){const w=e;e=m??(typeof b!="object"||b===null)?b:Object.assign({},e,b),o.forEach(v=>v(e,w))}},n=()=>e,h={setState:u,getState:n,getInitialState:()=>a,subscribe:t=>(o.add(t),()=>o.delete(t))},a=e=s(u,n,h);return h},L=s=>s?V(s):V;class Ee{constructor(e){Object.defineProperty(this,"uid",{enumerable:!0,configurable:!0,writable:!0,value:e}),Object.defineProperty(this,"_emitter",{enumerable:!0,configurable:!0,writable:!0,value:new de})}on(e,o){this._emitter.on(e,o)}once(e,o){this._emitter.once(e,o)}off(e,o){this._emitter.off(e,o)}emit(e,...o){const u=o[0];this._emitter.emit(e,{uid:this.uid,...u})}listenerCount(e){return this._emitter.listenerCount(e)}}function _e(s){return new Ee(s)}function je(s,e){return JSON.parse(s,(o,u)=>{let n=u;return n?.__type==="bigint"&&(n=BigInt(n.value)),n?.__type==="Map"&&(n=new Map(n.value)),e?.(o,n)??n})}function X(s,e){return s.slice(0,e).join(".")||"."}function Y(s,e){const{length:o}=s;for(let u=0;u<o;++u)if(s[u]===e)return u+1;return 0}function Re(s,e){const o=typeof s=="function",u=typeof e=="function",n=[],r=[];return function(h,a){if(typeof a=="object")if(n.length){const t=Y(n,this);t===0?n[n.length]=this:(n.splice(t),r.splice(t)),r[r.length]=h;const m=Y(n,a);if(m!==0)return u?e.call(this,h,a,X(r,m)):`[ref=${X(r,m)}]`}else n[0]=a,r[0]=h;return o?s.call(this,h,a):a}}function ke(s,e,o,u){return JSON.stringify(s,Re((n,r)=>{let f=r;return typeof f=="bigint"&&(f={__type:"bigint",value:r.toString()}),f instanceof Map&&(f={__type:"Map",value:Array.from(r.entries())}),e?.(n,f)??f},u),o??void 0)}function Ae(s){const{deserialize:e=je,key:o="wagmi",serialize:u=ke,storage:n=ne}=s;function r(f){return f instanceof Promise?f.then(h=>h).catch(()=>null):f}return{...n,key:o,async getItem(f,h){const a=n.getItem(`${o}.${f}`),t=await r(a);return t?e(t)??null:h??null},async setItem(f,h){const a=`${o}.${f}`;h===null?await r(n.removeItem(a)):await r(n.setItem(a,u(h)))},async removeItem(f){await r(n.removeItem(`${o}.${f}`))}}}const ne={getItem:()=>null,setItem:()=>{},removeItem:()=>{}};function qe(){const s=typeof window<"u"&&window.localStorage?window.localStorage:ne;return{getItem(e){return s.getItem(e)},removeItem(e){s.removeItem(e)},setItem(e,o){try{s.setItem(e,o)}catch{}}}}const B=256;let $=B,T;function Oe(s=11){if(!T||$+s>B*2){T="",$=0;for(let e=0;e<B;e++)T+=(256+Math.random()*256|0).toString(16).substring(1)}return T.substring($,$+++s)}function Ue(s){const{multiInjectedProviderDiscovery:e=!0,storage:o=Ae({storage:qe()}),syncConnectedChain:u=!0,ssr:n=!1,...r}=s,f=typeof window<"u"&&e?ve():void 0,h=L(()=>r.chains),a=L(()=>{const i=[],l=new Set;for(const d of r.connectors??[]){const C=t(d);if(i.push(C),!n&&C.rdns){const y=typeof C.rdns=="string"?[C.rdns]:C.rdns;for(const E of y)l.add(E)}}if(!n&&f){const d=f.getProviders();for(const C of d)l.has(C.info.rdns)||i.push(t(m(C)))}return i});function t(i){const l=_e(Oe()),d={...i({emitter:l,chains:h.getState(),storage:o,transports:r.transports}),emitter:l,uid:l.uid};return l.on("connect",S),d.setup?.(),d}function m(i){const{info:l}=i,d=i.provider;return D({target:{...l,id:l.rdns,provider:d}})}const b=new Map;function w(i={}){const l=i.chainId??g.getState().chainId,d=h.getState().find(y=>y.id===l);if(i.chainId&&!d)throw new F;{const y=b.get(g.getState().chainId);if(y&&!d)return y;if(!d)throw new F}{const y=b.get(l);if(y)return y}let C;if(r.client)C=r.client({chain:d});else{const y=d.id,E=h.getState().map(_=>_.id),j={},k=Object.entries(r);for(const[_,q]of k)if(!(_==="chains"||_==="client"||_==="connectors"||_==="transports"))if(typeof q=="object")if(y in q)j[_]=q[y];else{if(E.some(re=>re in q))continue;j[_]=q}else j[_]=q;C=ue({...j,chain:d,batch:j.batch??{multicall:!0},transport:_=>r.transports[y]({..._,connectors:a})})}return b.set(l,C),C}function v(){return{chainId:h.getState()[0].id,connections:new Map,current:null,status:"disconnected"}}let p;const c="0.0.0-canary-";z.startsWith(c)?p=Number.parseInt(z.replace(c,""),10):p=Number.parseInt(z.split(".")[0]??"0",10);const g=L(Ce(o?Pe(v,{migrate(i,l){if(l===p)return i;const d=v(),C=P(i,d.chainId);return{...d,chainId:C}},name:"store",partialize(i){return{connections:{__type:"Map",value:Array.from(i.connections.entries()).map(([l,d])=>{const{id:C,name:y,type:E,uid:j}=d.connector;return[l,{...d,connector:{id:C,name:y,type:E,uid:j}}]})},chainId:i.chainId,current:i.current}},merge(i,l){typeof i=="object"&&i&&"status"in i&&delete i.status;const d=P(i,l.chainId);return{...l,...i,chainId:d}},skipHydration:n,storage:o,version:p}):v));g.setState(v());function P(i,l){return i&&typeof i=="object"&&"chainId"in i&&typeof i.chainId=="number"&&h.getState().some(d=>d.id===i.chainId)?i.chainId:l}u&&g.subscribe(({connections:i,current:l})=>l?i.get(l)?.chainId:void 0,i=>{if(h.getState().some(d=>d.id===i))return g.setState(d=>({...d,chainId:i??d.chainId}))}),f?.subscribe(i=>{const l=new Set,d=new Set;for(const y of a.getState())if(l.add(y.id),y.rdns){const E=typeof y.rdns=="string"?[y.rdns]:y.rdns;for(const j of E)d.add(j)}const C=[];for(const y of i){if(d.has(y.info.rdns))continue;const E=t(m(y));l.has(E.id)||C.push(E)}o&&!g.persist.hasHydrated()||a.setState(y=>[...y,...C],!0)});function I(i){g.setState(l=>{const d=l.connections.get(i.uid);return d?{...l,connections:new Map(l.connections).set(i.uid,{accounts:i.accounts??d.accounts,chainId:i.chainId??d.chainId,connector:d.connector})}:l})}function S(i){g.getState().status==="connecting"||g.getState().status==="reconnecting"||g.setState(l=>{const d=a.getState().find(C=>C.uid===i.uid);return d?(d.emitter.listenerCount("connect")&&d.emitter.off("connect",I),d.emitter.listenerCount("change")||d.emitter.on("change",I),d.emitter.listenerCount("disconnect")||d.emitter.on("disconnect",R),{...l,connections:new Map(l.connections).set(i.uid,{accounts:i.accounts,chainId:i.chainId,connector:d}),current:i.uid,status:"connected"}):l})}function R(i){g.setState(l=>{const d=l.connections.get(i.uid);if(d){const y=d.connector;y.emitter.listenerCount("change")&&d.connector.emitter.off("change",I),y.emitter.listenerCount("disconnect")&&d.connector.emitter.off("disconnect",R),y.emitter.listenerCount("connect")||d.connector.emitter.on("connect",S)}if(l.connections.delete(i.uid),l.connections.size===0)return{...l,connections:new Map,current:null,status:"disconnected"};const C=l.connections.values().next().value;return{...l,connections:new Map(l.connections),current:C.connector.uid}})}return{get chains(){return h.getState()},get connectors(){return a.getState()},storage:o,getClient:w,get state(){return g.getState()},setState(i){let l;typeof i=="function"?l=i(g.getState()):l=i;const d=v();typeof l!="object"&&(l=d),Object.keys(d).some(y=>!(y in l))&&(l=d),g.setState(l,!0)},subscribe(i,l,d){return g.subscribe(i,l,d?{...d,fireImmediately:d.emitImmediately}:void 0)},_internal:{mipd:f,async revalidate(){const i=g.getState(),l=i.connections;let d=i.current;for(const[,C]of l){const y=C.connector;y.isAuthorized&&await y.isAuthorized()||(l.delete(y.uid),d===y.uid&&(d=null))}g.setState(C=>({...C,connections:l,current:d}))},store:g,ssr:!!n,syncConnectedChain:u,transports:r.transports,chains:{setState(i){const l=typeof i=="function"?i(h.getState()):i;if(l.length!==0)return h.setState(l,!0)},subscribe(i){return h.subscribe(i)}},connectors:{providerDetailToConnector:m,setup:t,setState(i){return a.setState(typeof i=="function"?i(a.getState()):i,!0)},subscribe(i){return a.subscribe(i)}},events:{change:I,connect:S,disconnect:R}}}}const Q=le({id:102031,name:"Creditcoin Testnet",nativeCurrency:{name:"Creditcoin",symbol:"CTC",decimals:18},rpcUrls:{default:{http:["https://rpc.cc3-testnet.creditcoin.network"]}},blockExplorers:{default:{name:"Blockscout",url:"https://creditcoin-testnet.blockscout.com"}},testnet:!0}),We=Ue({chains:[Q],transports:{[Q.id]:ge()}});export{Me as S,Q as a,We as c,D as i};

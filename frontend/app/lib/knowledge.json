[
  {
    "source": "core/architecture-and-concepts.md",
    "content": "# BuildCTC Project Architecture & Concepts\n\n## 1. 개요 (Overview)\n본 문서는 BuildCTC 프로토콜을 구성하는 핵심 **스마트 컨트랙트의 역할**과, 프론트엔드 연동의 중추인 **Wagmi/Viem**의 개념을 명확히 정의하기 위해 작성되었습니다.\n\n## 2. 스마트 컨트랙트 아키텍처 (Core Smart Contracts)\nBuildCTC 생태계는 다음 4개의 컨트랙트가 유기적으로 상호작용하며 작동합니다.\n\n### 🏛️ A. MockUSDC.sol (자금, Currency)\n*   **Role**: 이 생태계의 **기축 통화(Base Currency)**입니다.\n*   **Description**: 현실 세계의 USD 또는 USDC를 테스트넷 환경에서 시뮬레이션한 ERC-20 토큰입니다.\n*   **Key Functions**:\n    *   **Payment**: 투자자가 채권(Bond)을 구매할 때 지불하는 수단.\n    *   **Reward**: 투자 수익(이자)을 지급받는 수단.\n    *   **Faucet**: 테스트 환경에서 누구나 무료로 자금을 확보할 수 있는 기능 제공.\n\n### 📜 B. BondToken.sol (상품, Asset)\n*   **Role**: 투자자가 소유하는 **채권 인증서(Certificate)**입니다.\n*   **Description**: 특정 실물 자산(RWA)에 대한 투자 지분을 증명하는 **ERC-1155** 표준 토큰입니다.\n*   **Key Functions**:\n    *   **Proof of Investment**: \"나는 A 농장에 투자했다\"는 불변의 온체인 증명.\n    *   **Multi-Asset**: 하나의 컨트랙트로 다양한 종류의 채권(ID 1, ID 2...)을 발행 및 관리.\n    *   **Claim Right**: 이 토큰을 보유한 지갑만이 수익 배분(Yield)을 청구할 자격을 가짐.\n\n### 🏦 C. LiquidityPool.sol (거래소, Marketplace)\n*   **Role**: 자금과 채권을 교환하는 **중개소(Exchange)**입니다.\n*   **Description**: 은행 창구와 같으며, 투자자의 자금을 모아 채권을 발행해주고 모인 자금을 대출자(Borrower)에게 전달합니다.\n*   **Key Functions**:\n    *   **Invest (Purchase)**: 투자자로부터 `MockUSDC`를 받고, 즉시 `BondToken`을 발행(Mint)하여 지급.\n    *   **Withdraw**: 모인 자금을 RWA 운영 자금으로 인출.\n    *   **Access Control**: 유일하게 `BondToken`을 발행할 수 있는 권한(`MINTER_ROLE`)을 보유.\n\n### 💸 D. YieldDistributor.sol (정산소, Settlement)\n*   **Role**: 투자 수익을 계산하고 지급하는 **정산 시스템**입니다.\n*   **Description**: 배당금 지급 창구이며, 복잡한 수익률 계산과 지급 프로세스를 자동화합니다.\n*   **Key Functions**:\n    *   **Deposit Yield**: 운영 수익이 발생하면 관리자가 `MockUSDC`를 예치.\n    *   **Claim**: 투자자가 자신의 `BondToken` 보유량을 증명하면, 지분에 비례한 수익금을 계산하여 지급.\n    *   **Auto-Calculation**: Synthetix의 `RewardPerToken` 알고리즘을 사용하여 초 단위 수익 분배 가능.\n\n---\n\n## 3. 프론트엔드 연동 기술 (Frontend Web3 Stack)\n\n### 🔌 Wagmi (Control Center)\n*   **Definition**: React 애플리케이션과 이더리움(EVM) 블록체인을 연결하는 **통신 제어 센터**입니다.\n*   **Why we use it**:\n    *   **Chain Management**: \"우리는 Creditcoin Testnet만 사용한다\"는 규칙을 전역적으로 강제합니다.\n    *   **Wallet Connection**: MetaMask, Coinbase Wallet 등 수많은 지갑과의 연결 복잡성을 표준화된 훅(Hook)으로 처리합니다.\n    *   **Auto-Refresh**: 계정 변경, 네트워크 변경, 연결 해제 등의 이벤트를 자동으로 감지하고 UI를 갱신합니다.\n\n### 🛠️ Viem (Engine Room)\n*   **Definition**: Wagmi가 내부적으로 사용하는 **저수준(Low-level) 인터페이스 라이브러리**입니다. (과거 ethers.js의 대체재)\n*   **Why we use it**:\n    *   **Type Safety**: TypeScript 친화적으로 설계되어, ABI의 입출력 타입을 자동으로 추론해줍니다. (오류 방지)\n    *   **Lightweight**: 매우 가볍고 빠르며, 불필요한 기능을 덜어낸 순수 연산/통신 엔진입니다.\n\n### 🔄 전체 데이터 흐름 (Data Flow)\n1.  **Backend(Contract)**: `MockUSDC`, `BondToken` 등이 블록체인에 배포됨.\n2.  **Engine(Viem)**: 블록체인 노드(RPC)와 직접 통신하여 데이터를 가져옴.\n3.  **Controller(Wagmi)**: 가져온 데이터를 React 컴포넌트가 쓰기 편한 상태(State)로 변환하고 캐싱함.\n4.  **Frontend(UI)**: 사용자가 버튼을 누르면 Wagmi를 통해 지갑 서명을 요청하고 트랜잭션을 발생시킴.\n"
  },
  {
    "source": "core/db-specification.md",
    "content": "# Database Specification (DB 사양서)\n\n## 1. 개요\nBuildCTC 프로젝트는 RWA(Real World Asset) 토큰화 플랫폼으로서, 실물 자산인 대출 채권의 데이터와 블록체인 상의 트랜잭션을 연결하는 견고한 데이터 구조를 필요로 합니다. 본 문서는 Turso(SQLite)와 Drizzle ORM을 기반으로 한 데이터베이스 설계를 정의합니다.\n\n## 2. 기술 스택\n- **Engine**: SQLite (via Turso/LibSQL)\n- **ORM**: Drizzle ORM\n- **Validation**: Zod (Type-safe Schema Validation)\n- **Migrations**: Drizzle Kit\n\n## 3. 데이터 모델 (ERD 및 테이블 정의)\n\n### 3.1 Bonds (채권)\n채권의 상세 정보와 온체인 상태를 관리합니다.\n- `id`: (text/uuid) PK\n- `bond_id`: (integer) 온체인 토큰 ID (ERC-1155)\n- `borrower_name`: (text) 차입자 명칭\n- `region`: (text) 차입자 거주 지역 (예: Thailand, Bangkok)\n- `loan_amount`: (integer) 대출 원금 (USDC 단위, 6 decimals 기준)\n- `interest_rate`: (integer) 연 이자율 (Basis points, 예: 15% -> 1500)\n- `maturity_date`: (integer) 만기일 (Unix timestamp)\n- `status`: (text) 상태 (PENDING, ACTIVE, REPAID, DEFAULT)\n- `created_at`: (integer) 생성일자\n- `updated_at`: (integer) 수정일자\n\n### 3.2 Investors (투자자)\n플랫폼 사용자의 투자 정보 및 설정 정보를 관리합니다.\n- `id`: (text/uuid) PK\n- `wallet_address`: (text) 지갑 주소 (Unique)\n- `kyc_status`: (text) KYC 인증 상태 (NOT_STARTED, PENDING, VERIFIED, REJECTED)\n- `auto_reinvest`: (integer) 자동 재투자 여부 (0: false, 1: true)\n- `created_at`: (integer) 가입일자\n\n### 3.3 Investments (투자 내역)\n투자자가 채권에 투자한 개별 내역입니다.\n- `id`: (text/uuid) PK\n- `investor_id`: (text) FK -> investors.id\n- `bond_id`: (text) FK -> bonds.id\n- `token_amount`: (integer) 배정된 토큰 수량\n- `usdc_amount`: (integer) 투자된 USDC 금액\n- `transaction_hash`: (text) 온체인 트랜잭션 해시\n- `created_at`: (integer) 투자 실행 일시\n\n### 3.4 Yield Distributions (수익 배분)\n투자자에게 지급된 이자 수익 내역입니다.\n- `id`: (text/uuid) PK\n- `bond_id`: (text) FK -> bonds.id\n- `investor_id`: (text) FK -> investors.id\n- `yield_amount`: (integer) 지급된 수익 금액 (USDC)\n- `transaction_hash`: (text) 지급 트랜잭션 해시 (오프체인 기록 포함)\n- `distributed_at`: (integer) 지급 일시\n\n### 3.5 Repayments (상환 내역)\n차입자가 채권에 대해 상환한 원리금 내역입니다.\n- `id`: (text/uuid) PK\n- `bond_id`: (text) FK -> bonds.id\n- `amount`: (integer) 상환 금액\n- `repayment_date`: (integer) 상환 일시\n- `oracle_request_id`: (text) Creditcoin Oracle 요청 ID\n\n## 4. 무결성 및 보안 규칙\n1. **[DATABASE INTEGRITY RULE]** 모든 DDL 작업 전 반드시 데이터 덤프를 수행하거나 Git 체크포인트를 생성합니다.\n2. **Soft Deletes**: 주요 금융 데이터는 물리적 삭제 대신 `deleted_at` 컬럼을 통한 논리적 삭제를 권장합니다.\n3. **Audit Traces**: 모든 상태 변경(Status Update)은 히스토리가 추적 가능해야 합니다.\n\n## 5. Zod 통합 전략\n- Drizzle 스키마로부터 `select` 및 `insert` 스키마를 자동 생성하여 API 엔드포인트에서 데이터 검증에 활용합니다.\n- 예시: `createSelectSchema(bonds)`\n"
  },
  {
    "source": "core/ideathon_pitch.md",
    "content": "# BondBase: Ideathon Submission Summary\n\n## 프로젝트 명\n**BondBase: 크레딧코인 기반 RWA(실물자산) 채권 투자 & 오토-컴파운딩 프로토콜**\n*(BondBase: RWA Investment & Compound Yield Protocol on Creditcoin)*\n\n---\n\n## 1. 문제 정의 (The Problem)\n*   **DeFi의 한계**: 기존 암호화폐 시장은 높은 변동성과 투기적 성격으로 인해 안정적인 현금 흐름(Cash Flow)을 원하는 투자자들의 니즈를 충족시키지 못하고 있습니다.\n*   **RWA 접근성 부족**: 신흥국(예: 태국, 나이지리아 등)의 고수익 우량 대출 채권은 기관 투자자만의 전유물이었으며, 일반 투자자는 접근할 수 없었습니다.\n*   **투명성 부재**: 기존 핀테크 대출 플랫폼은 자금의 실제 이동 경로와 상환 내역이 불투명합니다.\n\n## 2. 솔루션 (Our Solution)\n**BondBase**는 실물 경제의 대출 채권을 **ERC-1155 표준으로 토큰화**하여, 누구나 소액으로 전 세계 우량 자산에 투자할 수 있는 투명한 **RWA(Real World Asset) 플랫폼**입니다.\n\n## 3. 핵심 기술 및 혁신 (Key Features & Innovation)\n우리는 단순한 토큰 발행을 넘어, **사용자 편의성(UX)**과 **자산 효율성**을 극대화한 **V2 자체 엔진**을 개발 완료하고 테스트넷에 배포했습니다.\n\n1.  **Hold-to-Earn (보유 시 자동 수익)**:\n    *   투자자가 별도의 스테이킹 액션(Staking Action)을 하지 않아도, 지갑에 채권을 보유하는 즉시 블록 단위로 이자가 계산되는 **무자각 수익 시스템**을 구현했습니다.\n2.  **Auto-Compounding (이자 재투자 시스템)**:\n    *   발생한 수익(USDC)을 클릭 한 번으로 원금(Bond Token)으로 전환하여 복리 효과를 극대화하는 **'Reinvest' 함수**를 내장했습니다.\n3.  **On-Chain Transparency (투명성)**:\n    *   모든 자금의 흐름, 이자 정산, 배분 내역이 Creditcoin 네트워크상에 투명하게 기록되며, 오라클을 통해 실물 상환 데이터를 검증합니다.\n\n## 4. 기대 효과 및 비전 (Impact & Vision)\n*   **Stable Real Yield**: 크립토 윈터(하락장)에도 영향받지 않는 연 10~15%대의 안정적인 실물 기반 수익을 제공합니다.\n*   **Financial Inclusion**: 투자자에게는 새로운 수익원을, 신흥국 소상공인에게는 금융 기회를 제공하여 블록체인의 사회적 가치를 실현합니다.\n*   **Scalability**: 현재의 단일 자산을 넘어, 다양한 만기와 리스크 등급을 가진 채권을 통합 관리하는 '멀티 에셋 플랫폼'으로 확장할 준비를 마쳤습니다.\n\n---\n\n## [심사위원에게 어필할 한 문장 요약]\n> **\"BondBase는 블록체인의 투명성과 RWA의 안정성을 결합하고, '복리 재투자' 기술을 더해 누구나 쉽고 안전하게 실물 경제의 성장을 공유받는 미래형 투자 플랫폼입니다.\"**\n"
  },
  {
    "source": "core/project-summary.md",
    "content": "# Project Summary: BuildCTC (RWA Yield Protocol)\n\n## 1. 프로젝트 개요\n**BuildCTC (Build Creditcoin Tokenized Credit)**는 Creditcoin 2.0 네트워크를 기반으로 하는 실물 자산(Real World Assets, RWA) 수익률 프로토콜입니다. 신흥 시장(초기 태국 중심)의 소상공인 대출 채권을 온체인 토큰화하여, DeFi 투자자들에게 암호화폐 시장 변동성과 무관한 안정적인 실물 경제 수익을 제공합니다.\n\n## 2. 핵심 가치 제안 (Core Value Proposition)\n- **자산 토큰화 (Asset Tokenization)**: ERC-1155 표준을 활용하여 대출 채권을 분할 가능한 단위로 발행, 투자 접근성 및 유동성 확보.\n- **데이터 투명성 (Transparency)**: Creditcoin 네트워크의 대출/상환 이력 데이터를 통해 실물 자산의 가치를 온체인에서 실시간 검증.\n- **소셜 임팩트 (Social Impact)**: 신흥 시장 소상공인에게 금융 기회를 제공하고, 투자자에게는 시각화된 ESG 지표를 제공.\n- **크로스체인 연동 (Cross-Chain)**: Creditcoin Gateway를 통해 이더리움, 폴리곤 등 다양한 체인의 투자자 참여 유도.\n\n## 3. 기술 아키텍처 (Technical Architecture)\n### 3.1 스마트 컨트랙트 (Solidity)\n- **BondToken (ERC-1155)**: 채권 발행 및 소유권 관리.\n- **LiquidityPool**: 투자자의 안정적인 자산(USDC) 예치 및 채권 매입 자금 관리.\n- **YieldDistributor**: 상환 데이터에 기반한 자동 수익 계산 및 배분.\n- **ReservePool**: 디폴트 리스크를 대비한 안전망(Reserve Fund) 관리.\n- **OracleAdapter**: Creditcoin Universal Oracle을 통한 실물 데이터 연동.\n\n### 3.2 백엔드 & 프론트엔드\n- **Backend**: Node.js/Python 기반 API, PostgreSQL(Supabase), Zod/Pydantic 스키마 검증.\n- **Frontend**: Next.js, Tailwind CSS, shadcn/ui 기반의 직관적인 투자 및 임팩트 대시보드.\n\n## 4. 리스크 관리 체계\n- **리저브 풀 (Reserve Pool)**: 수익의 일정 비율(5-10%)을 적립하여 손실 발생 시 우선 보전.\n- **손실 분산 (Loss Distribution)**: 여러 채권으로 포트폴리오를 구성하여 특정 채권의 디폴트 영향을 최소화.\n- **신용 평가**: Creditcoin의 온체인 데이터를 활용한 신용 점수 시스템 구축.\n\n## 5. 로드맵 (Phase별 요약)\n1. **Phase 1 (기초)**: 인프라 설정, 스마트 컨트랙트 기본 구조 설계 및 단위 테스트.\n2. **Phase 2 (핵심)**: 유동성 풀 및 수익 배분 시스템 완성, 오라클 데이터 연동.\n3. **Phase 3 (리스크/UI)**: 리저브 풀 구현, 투자자 대시보드 및 ESG 지도 시각화.\n4. **Phase 4 (확장)**: Creditcoin Gateway 통합 및 기관 투자자 유치, 타 국가(동남아/아프리카) 확장.\n\n---\n*본 문서는 `docs/PLAN.md` 및 `docs/IMPLEMENTATION_PLAN.md`를 기반으로 요약되었습니다.*\n"
  },
  {
    "source": "core/ui-specification.md",
    "content": "# UI & Design Specification\n\n## 1. 기반 시스템 (Foundation)\nBuildCTC의 UI는 **shadcn/ui**의 최신 프리셋 시스템을 기반으로 구축됩니다. 이를 통해 프로젝트 전반에 걸쳐 일관된 디자인 언어와 고품질의 컴포넌트를 유지합니다.\n\n### 1.1 초기화 명령어 (Initialization Command)\n프로젝트 UI 환경 구축 시 다음 명령어를 사용하여 지정된 프리셋을 적용합니다:\n```bash\nnpx shadcn@latest create --preset \"https://ui.shadcn.com/init?base=base&style=nova&baseColor=neutral&theme=neutral&iconLibrary=hugeicons&font=inter&menuAccent=subtle&menuColor=default&radius=default&template=vite\" --template vite\n```\n\n## 2. 디자인 토큰 및 설정 (Design Tokens)\n위 프리셋에 포함된 핵심 디자인 설정은 다음과 같습니다:\n\n- **Style**: `Nova` (현대적이고 정교한 비주얼 스타일)\n- **Colors**:\n  - Base Color: `Neutral`\n  - Theme Color: `Neutral` (신뢰감을 주는 무채색 톤 기반)\n- **Typography**: `Inter` (가독성이 뛰어난 산세리프 폰트)\n- **Icon Library**: `Hugeicons` (세련된 선형 아이콘 시스템)\n- **Menu Style**: `Subtle` 액센트 및 `Default` 컬러 적용\n- **Border Radius**: `Default`\n\n## 3. UI 구현 원칙\n- **일관성**: 모든 컴포넌트는 커스텀 인라인 스타일 대신 지정된 디자인 토큰과 Tailwind 유틸리티 클래스를 사용합니다.\n- **반응형**: 모바일 우선(Mobile-first) 접근 방식을 따르며, 모든 화면은 다양한 해상도에 대응해야 합니다.\n- **접근성(A11y)**: shadcn/ui와 Radix UI가 제공하는 접근성 표준을 준수합니다.\n\n## 4. 참조 리소스\n- **디자인 샘플(Stitch)**: [Stitch Project URL](https://stitch.withgoogle.com/projects/17193233867447468760)\n- **아이콘 참조**: Hugeicons 라이브러리 공식 문서 참조.\n\n---\n*본 문서는 프로젝트의 시각적 일관성을 위해 작성되었으며, UI 관련 모든 개발 작업의 기준이 됩니다.*\n"
  },
  {
    "source": "features/admin-portal-specification.md",
    "content": "# Admin Portal Specification: Yield Distribution Management\n\n## 1. 개요 (Overview)\n본 문서는 BondBase 프로젝트의 안전하고 효율적인 운영을 위한 **관리자 전용 포털(Admin Portal)**의 설계 사양을 정의합니다. 기존의 블록 익스플로러를 통한 수동 운영 방식에서 탈피하여, 웹 인터페이스 내에서 직관적이고 오류 없는 자산 운영 환경을 구축하는 것을 목적으로 합니다.\n\n---\n\n## 2. 필요성 및 목표 (Goal)\n- **보안성**: 브라우저 보안 경고(SSL 등) 없이 신뢰할 수 있는 환경에서 트랜잭션 실행.\n- **편의성**: 복잡한 소수점 단위 변환 및 중복 트랜잭션(`Approve` → `Deposit`)을 시스템이 자동 관리.\n- **정확성**: 실시간 잔액 및 한도(Allowance) 조회를 통해 입금 실패 및 가스비 낭비 방지.\n\n---\n\n## 3. 핵심 기능 요구사항 (Core Requirements)\n\n### 3.1 지갑 연결 및 권한 검증\n- **Wallet Connection**: WalletConnect, MetaMask 연동 지원.\n- **Access Control**: 연결된 지갑 주소가 컨트랙트 내 `DISTRIBUTOR_ROLE` 권한을 보유했는지 즉시 검증. 권한이 없을 경우 모든 입력창 비활성화 및 경고 표시.\n\n### 3.2 스마트 수익 배분 모듈 (Smart Yield Distribution)\n- **Step-by-Step Flow**:\n    1. **수량 입력**: 관리자가 달러 단위(USDC)로만 입력 (예: 1000).\n    2. **자동 분석**: 시스템이 `Allowance`를 조회하여 `Approve`가 필요한지 자동으로 판단.\n    3. **단일 UI 액션**: 관리자는 하나의 버튼을 누르되, 시스템 내부적으로 `Approve` → `Deposit` 순서로 트랜잭션 가이드 제공.\n- **Unit Conversion**: 프론트엔드에서 `parseUnits(amount, 18)`를 자동 수행하여 휴먼 에러 차단.\n\n### 3.3 대시보드 모니터링\n- **관리자 잔액**: 현재 관리자 지갑에 보유 중인 `MockUSDC` 수량 상시 노출.\n- **글로벌 보상 상태**: `rewardPerTokenStored`를 조회하여 현재까지 배분된 총 이자 현황 시각화.\n- **채권 현황**: 현재 수익 배분 대상이 되는 채권(Target Bond ID)과 해당 채권의 총 발행량(`totalSupply`) 표시.\n\n---\n\n## 4. UI/UX 설계 가이드라인\n\n### 4.1 트랜잭션 진행 표시 (Transaction Stepper)\n- 여러 개의 트랜잭션이 발생하므로 시각적 프로그레스 바(Progress Bar) 필수.\n- 각 트랜잭션의 컨펌(Confirm) 여부를 사용자에게 즉각 피드백.\n\n### 4.2 안전 장치 (Safety Guards)\n- **잔액 초과 방지**: 지갑 잔액보다 큰 금액 입력 시 \"Balance Insufficient\" 메시지와 함께 버튼 비활성화.\n- **이중 클릭 방지**: 트랜잭션 처리 중 버튼 중복 클릭 원천 차단.\n- **경고 배너**: 실행 전 \"본 작업은 실물 자산 수익을 확정 짓는 트랜잭션이며 취소가 불가능함\"을 명시.\n\n---\n\n## 5. 기술 스택 및 연동 사양\n- **Frontend**: Next.js (App Router), Tailwind CSS, shadcn/ui.\n- **Library**: `wagmi`, `viem` (V2)를 통한 온체인 데이터 통신.\n- **Smart Contracts**:\n    - `MockUSDC`: `approve`, `balanceOf` 호출.\n    - `YieldDistributor`: `depositYield`, `earned`, `rewardPerTokenStored` 호출.\n\n---\n\n## 6. 향후 확장 계획\n- **다중 채권 관리**: 서로 다른 Bond ID에 대해 각각의 수익률을 개별 배분하는 기능.\n- **운용 로그**: 배분 히스토리를 DB(Turso)에 기록하여 관리 대장 자동화.\n- **자동화 알림**: 수익 배분 완료 시 투자자들에게 서비스 내 알림 전송 연동.\n"
  },
  {
    "source": "guides/oracle_operation_guide.md",
    "content": "# Oracle Integration & Operation Guide (Detailed)\n\n이 가이드는 BuildCTC 플랫폼의 핵심 데이터 레이어인 **오라클 시스템(Oracle System)**의 운영 및 관리를 위한 종합 매뉴얼입니다. 본 문서는 Phase 1(Mock)과 Phase 2(Adapter)를 모두 포함하며, 실제 운영 환경에서의 데이터 무결성 유지를 목표로 합니다.\n\n---\n\n## 1. 개요 (Background)\n\nBuildCTC는 실물 자산(RWA) 기반의 이익을 배분합니다. 온체인 스마트 컨트랙트는 오프체인 상환 데이터를 직접 알 수 없으므로, **OracleAdapter**가 게이트웨이 역할을 수행하여 검증된 데이터를 시스템에 주입합니다.\n\n- **Phase 1 (MockOracle)**: 단순 수익 배분 가용성 테스트용.\n- **Phase 2 (OracleAdapter)**: 자산 상태 관리, 증분 수익 배분, 검증 증명(Proof)을 포함한 정식 운영 모델.\n\n---\n\n## 2. 사전 요구 사항 (Prerequisites)\n\n시스템 운영을 위해 다음 조건이 충족되어야 합니다.\n\n### A. 네트워크 및 지갑 설정\n- **네트워크**: Creditcoin Testnet (Chain ID: 1020301)\n- **지갑**: MetaMask 또는 유사한 EVM 호환 지갑\n- **필요 자산**: \n    - 트랜잭션용 CTC (Testnet)\n    - 수익 배분용 MockUSDC (Testnet)\n\n### B. 권한 설정 (Role Management)\n오라클 호출을 위해서는 스마트 컨트랙트 상에 다음 권한이 있어야 합니다.\n1. `OracleAdapter.ORACLE_ROLE`: 호출자(관리자 또는 봇)에게 부여.\n2. `YieldDistributor.DISTRIBUTOR_ROLE`: `OracleAdapter` 계약 주소에 부여 (이미 초기화 완료).\n\n---\n\n## 3. 스마트 컨트랙트 주소 (Testnet)\n\n| Contract | Address | Purpose |\n| :--- | :--- | :--- |\n| **OracleAdapter** | `0x4F4D9a44b364A039976bC6a134a78c1Df1c7D50E` | 주요 데이터 입구 (V2) |\n| **MockOracle** | `0x4022BC37a1F9030f9c0dCA179cb1fFaF26E59bcE` | 레거시/기초 테스트용 (V1) |\n| **YieldDistributor** | `0xEbBa8Cec7Dee65bE9263e6378b33EC6D6Dba1308` | 수익 계산 및 유보 엔진 |\n| **MockUSDC** | `0x97A41Ff77f70e9328A20b62b393F8Fb0E7e49364` | 정산용 토큰 |\n\n---\n\n## 4. [운영 매뉴얼] Advanced Oracle Hub\n\n이 섹션은 Phase 2 기준의 정식 운영 방식입니다.\n\n### 4.1 데이터 입력 필드 상세 사양\n- **Asset Stream (Bond ID)**: 데이터를 업데이트할 대상 채권 ID.\n- **Cumulative Principal Paid**: 대출 실행 시점부터 현재까지 상환된 **총 원금**. (단위: $)\n- **Cumulative Interest Paid**: 대출 실행 시점부터 현재까지 상환된 **총 이자**. (단위: $)\n    - **중요**: 이 시스템은 '증분(Delta)' 방식입니다. 만약 지난번에 $100을 입력했고 이번에 $150을 입력하면, 시스템은 자동으로 차액인 **$50**만큼만 투자자에게 배분합니다.\n- **Asset Operational Status**:\n    - `Active` (0): 정상 상환 중 혹은 운용 중.\n    - `Repaid` (1): 모든 원리금이 상환되어 채권이 종료됨.\n    - `Default` (2): 연체 또는 상환 불능 상태 발생. (투자자에게 경고 알림 트리거용)\n- **Verification Proof**: 데이터의 근거가 되는 외부 증빙(예: IPFS 해시, 공시 URL, 파트너 서명 데이터 등).\n\n### 4.2 실행 프로세스 (Step-by-Step)\n1.  `/admin` 페이지의 **Advanced Oracle Hub**로 접속합니다.\n2.  대상 Bond를 선택하고 최신 누적 상환 데이터를 입력합니다.\n3.  하단의 **\"New Yield to Distribute\"** 수치를 확인합니다. (이 수치가 0보다 커야 실제 수익이 배분됩니다.)\n4.  `1. Approve Delta` 클릭: 지갑에서 배분할 차액만큼의 USDC 사용을 컨트랙트에 허용합니다.\n5.  `2. Sync Status` 클릭: 온체인에 데이터를 기록하고 수익 배분을 확정합니다.\n\n---\n\n## 5. 데이터 흐름 및 로직 (Behind the Scenes)\n\n```mermaid\ngraph TD\n    A[Admin/Relayer Bot] -->|updateAssetStatus| B(OracleAdapter)\n    B -->|Check Delta| C{Is New Interest > Old?}\n    C -->|Yes| D[Transfer USDC Delta from Admin to YieldDistributor]\n    D -->|depositYield| E(YieldDistributor)\n    E -->|Update Index| F[Investor Portfolio Real-time Accrual]\n    C -->|No| G[Update Status Only, No Fund Transfer]\n```\n\n### 증분(Delta) 계산의 이점\n- **멱등성(Idempotency)** 보장: 동일한 데이터를 여러 번 전송해도 이미 배분된 수익은 중복 배분되지 않습니다.\n- **정합성 유지**: 오프체인 서비스의 누적 상환 데이터와 온체인 기록을 1:1로 일치시킵니다.\n\n---\n\n## 6. 트러블슈팅 (FAQ)\n\n**Q1: \"Insufficient Allowance\" 에러가 발생합니다.**\n- **원인**: 배분할 이자 금액(Delta)만큼의 USDC 승인(Approve)이 되지 않았습니다.\n- **해결**: `Approve Delta` 버튼을 먼저 실행하여 지갑에서 승인을 완료하십시오.\n\n**Q2: \"Unauthorized\" 에러가 뜹니다.**\n- **원인**: 현재 연결된 지갑 주소가 `OracleAdapter`의 `ORACLE_ROLE`을 가지고 있지 않습니다.\n- **해결**: Admin 권한이 있는 계정으로 `/admin` 기능을 확인하거나, 관리자에게 주소 등록을 요청하십시오.\n\n**Q3: 상환 상태를 바꿨는데 수익 배분이 안 됩니다.**\n- **원인**: `Cumulative Interest Paid` 값이 이전 기록과 동일하거나 더 낮을 경우 이자 배분 로직은 실행되지 않고 상태만 업데이트됩니다.\n- **해결**: 이자 배분을 위해서는 실제 누적 이자 수치가 증가해야 합니다.\n\n---\n\n## 7. 보안 관리 지침\n\n- **Oracle Role 분리**: 운영의 안전성을 위해 오라클 호출(Update) 권한과 관리자(Role Grant/Admin) 권한을 분리하여 관리하십시오.\n- **Proof 기록 의무화**: 모든 업데이트 시 반드시 `verifyProof`를 포함하여 추후 감사(Audit)가 가능하도록 하십시오.\n- **주기적 감사**: `AssetStatusUpdated` 이벤트를 모니터링하여 인가되지 않은 시점의 대규모 데이터 변동을 감시하십시오.\n\n---\n**최종 업데이트**: 2026-01-17\n**버전**: v2.1 (Oracle Phase 2 Integration)\n**작성**: BuildCTC Core Team / Antigravity Agent\n"
  },
  {
    "source": "guides/user-testing-guide.md",
    "content": "# BondBase 알파 테스트 사용자 가이드\n\n본 문서는 **BondBase (V2)**의 알파 테스트에 참여하는 사용자를 위한 단계별 가이드입니다. \n테스터는 RWA(실물자산) 채권에 투자하고, 이자를 수령하거나 재투자하여 복리 효과를 체험할 수 있습니다.\n\n---\n\n## 1. 사전 준비 (Prerequisites)\n\n테스트를 진행하기 위해 **MetaMask** 지갑과 **테스트넷 코인(CTC)**이 필요합니다.\n\n### A. 네트워크 설정 (Creditcoin Testnet)\nMetaMask에 아래 네트워크를 추가해 주세요. (자동으로 추가되지 않는 경우 수동 입력)\n\n| 항목 | 값 |\n| :--- | :--- |\n| **Network Name** | Creditcoin Testnet |\n| **RPC URL** | `https://rpc.cc3-testnet.creditcoin.network` |\n| **Chain ID** | `102031` |\n| **Currency Symbol** | `CTC` |\n| **Block Explorer** | `https://creditcoin-testnet.blockscout.com` |\n\n### B. 가스비(CTC) 받기\n트랜잭션 수수료(Gas Fee)를 지불하기 위해 CTC 코인이 필요합니다.\n1. [Creditcoin Discord](https://discord.gg/creditcoin) 접속\n2. `#testnet-faucet` 채널 이동\n3. 명령어 입력: `/faucet <본인의_지갑_주소>`\n   - 예: `/faucet 0x1234...abcd`\n\n---\n\n## 2. 테스트 시작하기 (Getting Started)\n\n### 1단계: 지갑 연결 및 투자금 확보\n1. **BondBase 웹사이트**에 접속합니다.\n2. 우측 상단 **[Connect Wallet]** 버튼을 눌러 지갑을 연결합니다.\n3. 좌측 메뉴 **Settings > Wallet** 탭으로 이동합니다.\n4. **\"Testnet Faucet\"** 섹션의 **[Get 1,000 USDC]** 버튼을 클릭합니다.\n   - *이것은 투자를 위한 가상의 달러(MockUSDC)입니다.*\n   - *지갑 승인(Approve) 및 트랜잭션 서명이 필요합니다.*\n\n### 2단계: 채권 투자 (Invest)\n1. 좌측 메뉴 **Bond Market**으로 이동합니다.\n2. 원하는 채권 카드의 **[Invest]** 버튼을 클릭합니다. (예: Bond #1)\n3. 투자할 금액(예: `100`)을 입력하고 **[Purchase Bond]**를 클릭합니다.\n4. 트랜잭션이 완료되면 \"Purchase Successful\" 메시지가 뜹니다.\n\n---\n\n## 3. 수익 관리 체험 (Yield Experience)\n\nBondBase V2는 **\"보유가 곧 이자(Hold to Earn)\"** 시스템을 채택하고 있습니다. 별도의 예치 과정 없이 채권을 보유하기만 하면 이자가 발생합니다.\n\n### 3단계: 수익 확인 (Portfolio)\n1. 좌측 메뉴 **My Portfolio**로 이동합니다.\n2. **\"Accrued Profit\"** (미지급 수익) 항목을 확인합니다.\n   - *초기에는 `$0.00`입니다. 관리자가 수익을 배분하는 순간 실시간으로 숫자가 올라갑니다.*\n   - *(테스트 중인 관리자에게 \"배분해주세요\"라고 요청하세요!)*\n\n### 4단계: 재투자 체험 (Reinvest & Compound) 🌟\n발생한 이자를 현금화하지 않고, 원금에 합쳐서 **복리 효과**를 누려보세요.\n\n1. 이자가 쌓인 상태에서 **[REINVEST]** 버튼을 클릭합니다.\n2. 트랜잭션을 승인하면:\n   - **Accrued Profit**은 `$0.00`으로 초기화됩니다.\n   - 대신 **Holdings (보유 원금)**이 이자 금액만큼 **증가**합니다.\n   - *예: 100 USDC 원금 + 10 USDC 이자 -> 재투자 후 110 USDC 원금*\n\n---\n\n## 4. 문제 해결 (Troubleshooting)\n\n*   **Q: 버튼이 눌리지 않아요.**\n    *   A: 지갑에 가스비(CTC)가 충분한지 확인하세요. 최소 1 CTC 이상 보유를 권장합니다.\n*   **Q: 이자가 안 들어와요.**\n    *   A: 관리자가 아직 `Distribute Yield`를 실행하지 않았을 수 있습니다. 또는 채권 구매가 트랜잭션 실패로 처리되었는지 확인하세요.\n"
  },
  {
    "source": "guides/yield-operation-guide.md",
    "content": "# 수익 배분 및 입금 운영 가이드\n\n본 문서는 관리자가 실물 자산(RWA) 수익을 블록체인에 반영할 때, **이 문서 하나만으로 모든 과정을 끝낼 수 있도록** 설계되었습니다. 다른 기술 문서를 찾아볼 필요 없이 아래 단계만 따라오세요.\n\n---\n\n## 1. 운영 전 필수 정보 (Network Info)\n\n트랜잭션을 실행하기 위해 지갑(MetaMask 등)이 아래 네트워크로 설정되어 있어야 합니다.\n\n*   **네트워크 이름**: Creditcoin Testnet\n*   **RPC URL**: `https://rpc.testnet.creditcoin.network`\n*   **체인 ID**: `102031`\n*   **통화 기호**: `CTC`\n*   **블록 익스플로러**: [https://creditcoin-testnet.blockscout.com/](https://creditcoin-testnet.blockscout.com/)\n\n---\n\n## 2. 주요 대상 주소 (Target Addresses)\n\n이 주소들을 복사하여 사용하세요.\n\n| 항목 | 주소 (복사해서 사용) | 역할 |\n| :--- | :--- | :--- |\n| **수익금 토큰 (MockUSDC)** | `0x97A41Ff77f70e9328A20b62b393F8Fb0E7e49364` | 관리자가 보유한 수익금 화폐 |\n| **입금처 (YieldDistributor)** | `0xEbBa8Cec7Dee65bE9263e6378b33EC6D6Dba1308` | **수익금을 보낼 금고 주소** |\n\n---\n\n## 3. 실전 입금 가이드 (Step-by-Step)\n\n### [준비 단계] 지갑 연결하기\n1. 위 **블록 익스플로러** 링크를 클릭하여 접속합니다.\n2. 각 단계의 컨트랙트 주소를 검색창에 입력합니다.\n3. **'Contract'** 탭 -> **'Write Contract'** 탭을 클릭합니다.\n4. **'Connect to Web3'** 버튼을 눌러 관리자 지갑(MetaMask)을 연결합니다.\n\n---\n\n### [1단계] 수익금 금고 사용 승인 (Approve)\n금고가 관리자 지갑에서 돈을 가져갈 수 있게 허락하는 단계입니다.\n\n1. **대상**: [MockUSDC 컨트랙트 바로가기](https://creditcoin-testnet.blockscout.com/address/0x97A41Ff77f70e9328A20b62b393F8Fb0E7e49364?tab=write_contract)\n2. **함수**: `approve` 선택\n3. **입력란**:\n    *   `spender (address)`: `0xEbBa8Cec7Dee65bE9263e6378b33EC6D6Dba1308` (금고 주소)\n    *   `value (uint256)`: 배분할 총액 (주의: 뒤에 **0을 18개** 붙여야 합니다.)\n        *   *예시: 1,000 USDC 배분 시 -> `1000000000000000000000` 입력*\n4. **실행**: 'Write' 버튼 클릭 후 지갑에서 승인\n\n---\n\n### [2단계] 수익금 실제 배분 (Deposit)\n금고에 돈을 넣고 투자자들에게 배분 명령을 내리는 단계입니다.\n\n1. **대상**: [YieldDistributor 컨트랙트 바로가기](https://creditcoin-testnet.blockscout.com/address/0xEbBa8Cec7Dee65bE9263e6378b33EC6D6Dba1308?tab=write_contract)\n2. **함수**: `depositYield` 선택\n3. **입력란**:\n    *   `bondId (uint256)`: 배분할 채권의 ID (예: `1`)\n    *   `amount (uint256)`: 1단계에서 입력했던 **숫자와 정확히 동일하게** 입력\n        *   *예시: `1000000000000000000000`*\n4. **실행**: 'Write' 버튼 클릭 후 지갑에서 승인\n\n---\n\n## 4. 운영 꿀팁 (Operations Tip)\n\n*   **배분 주기**: 채권의 실제 이자 발생 주기에 맞춰 주 1회 또는 월 1회 정기적으로 실행하세요.\n*   **금액 확인**: 입금 후 [포트폴리오 대시보드](https://blockchain-bond-base.vercel.app/portfolio)에서 \"Unclaimed Yield\" 숫자가 올라갔는지 바로 확인하세요.\n*   **에러 발생 시**: 지갑에 `CTC` 잔액이 부족하여 가스비를 못 내는 것은 아닌지 가장 먼저 확인하세요.\n\n---\n\n## 5. 문의 및 기술 지원\n시스템 장애나 주소 변경이 필요한 경우 개발팀에 연동된 스마트 컨트랙트 재배포를 요청하세요.\n\n---\n\n## 4. 수익금 계산 및 노출 원리\n\n관리자가 단 한 번의 `depositYield`를 실행하면, 스마트 컨트랙트는 내부적으로 다음 과정을 **즉시** 처리합니다.\n\n1.  **지분 파악**: 현재 `YieldDistributor`에 예치(Stake)된 채권의 전체 수량을 확인합니다.\n2.  **보상액 업데이트**: `rewardPerTokenStored` 변수를 업데이트하여, 채권 1개당 돌아갈 새로운 수익금을 산출합니다.\n    *   공식: `새로운 보상액 = 기존 보상액 + (입금액 / 전체 채권 수)`\n3.  **개별 조회**: 투자자가 프론트엔드 포트폴리오 화면에 접속하면, 컨트랙트의 `earned(address user)` 함수가 실시간으로 호출되어 해당 사용자가 받을 수 있는 보상 숫자가 `$0.0000`에서 실제 숫자로 바뀌게 됩니다.\n\n---\n\n## 5. 주의 사항 및 팁\n\n*   **Holding Only (Holding = Yield)**: V2 업데이트로 인해 투자자는 별도로 채권을 맡길(Stake) 필요가 없습니다. 지갑에 채권(BondToken)을 **보유하고만 있어도** 즉시 이자 대상에 포함됩니다.\n*   **가스비 효율**: 투자자가 매 블록마다 수익을 수령하는 것이 아니라, 관리자가 한 번에 많은 수익을 입금하고 투자자가 원할 때 한 번에 수령(Claim)하는 `Pull Pattern`을 사용하여 네트워크 비용을 절약합니다.\n*   **운영 주기**: 매일, 매주 또는 매월 등 정기적인 운영 주기에 맞춰 수익을 입금하는 것을 권장합니다.\n"
  },
  {
    "source": "plans/gasless_transaction_plan.md",
    "content": "# UX Upgrade Plan: Gasless Transaction Implementation\n**Target Version**: V3 or Later\n**Purpose**: Reduce user onboarding friction by subsidizing gas fees (CTC) for bond interactions.\n\n---\n\n## 1. 개요 (Overview)\n현재 사용자는 모든 트랜잭션(투자, 클레임 등)을 위해 테스트넷 코인(CTC)을 직접 확보해야 합니다. 이는 Web3에 익숙하지 않은 사용자에게 큰 진입 장벽입니다. \n본 문서는 서비스 제공자가 가스비를 대납(Paymaster)하여, 사용자는 서명만으로 기능을 이용할 수 있게 하는 **Gasless(Meta-Transaction)** 도입 계획을 정리합니다.\n\n---\n\n## 2. 기술 아키텍처 (Technical Architecture)\n\n표준 **ERC-2771 (Trusted Forwarder)** 패턴을 도입하여 구현합니다.\n\n### 2.1 구성 요소\n1.  **User (Wallet)**: 트랜잭션을 직접 전송하지 않고, 의도(Intent)가 담긴 데이터에 서명(EIP-712)만 수행.\n2.  **Relayer (Backend)**: 사용자의 서명을 받아 검증한 뒤, 자신의 가스비(CTC)를 사용하여 블록체인에 트랜잭션 전송.\n3.  **Forwarder (Contract)**: Relayer로부터 요청을 받아 서명을 검증하고, 실제 타겟 컨트랙트(BondToken 등)를 호출.\n4.  **Target Contracts**: `ERC2771Context`를 상속받아, 요청자가 Relayer가 아닌 '원래 사용자'임을 인식.\n\n---\n\n## 3. 구현 상세 (Implementation Steps)\n\n### Step 1: 스마트 컨트랙트 업그레이드\n기존 모든 컨트랙트에 `ERC2771Context` 적용이 필요합니다.\n\n*   **BondToken.sol / YieldDistributorV2.sol**:\n    *   상속: `is ERC2771Context`\n    *   변경: `msg.sender` -> `_msgSender()` 로 전면 교체.\n    *   생성자: Trusted Forwarder 주소를 주입받도록 수정.\n\n```solidity\n// 예시 코드\nimport \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\n\ncontract YieldDistributorV2 is ERC2771Context {\n    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) { ... }\n\n    function claimYield(uint256 bondId) external {\n        address user = _msgSender(); // msg.sender 대신 사용\n        ...\n    }\n}\n```\n\n### Step 2: Relayer 인프라 구축\n다음 솔루션 중 하나를 선택하여 도입합니다.\n\n*   **옵션 A: Saas (추천 - Gelato, Biconomy, OpenZeppelin Defender)**\n    *   별도 서버 구축 없이 API 키만으로 사용 가능.\n    *   통계 및 가스비 추적 대시보드 제공.\n*   **옵션 B: 자체 구축 (OpenGSN)**\n    *   자체 Relayer 서버 운영. 유지보수 비용 높음.\n\n### Step 3: 프론트엔드 연동\n`wagmi/viem` 로직을 다음과 같이 변경합니다.\n\n*   **BEFORE**: `writeContract` (지갑 팝업 -> 가스비 승인)\n*   **AFTER**: \n    1.  `signTypedData` (지갑 팝업 -> 서명만, 가스비 0)\n    2.  서명 데이터를 우리 백엔드 API (`/api/relay`)로 전송.\n    3.  백엔드가 블록체인 전송 후 TxHash 반환.\n\n---\n\n## 4. 보안 고려사항 (Security)\n\n1.  **Trusted Forwarder 관리**: Forwarder 주소는 절대적으로 신뢰할 수 있어야 하며, 변경 불가능하거나 Timelock이 걸려야 함.\n2.  **DoS 방지 (Rate Limiting)**: 한 사용자가 무한정 트랜잭션을 보내 가스비를 고갈시키지 않도록 API 레벨에서 요청 횟수 제한 필요.\n3.  **화이트리스트**: 우리가 허용한 함수(`purchase`, `reinvest` 등)만 대납하도록 Forwarder 설정.\n\n---\n\n## 5. 마이그레이션 전략\n기존 배포된 V2 컨트랙트는 `ERC2771`을 지원하지 않으므로, 도입 시 **전체 재배포(Redeploy) 및 데이터 마이그레이션**이 필수입니다. 따라서 주요 버전 업그레이드(V3) 시점에 적용하는 것이 적절합니다.\n"
  },
  {
    "source": "reports/17_v2_deployment_result.md",
    "content": "# 17. Integrated V2 System Deployment Result\n\n## 1. 개요\n2026년 1월 16일 수행된 **통합 스테이킹 및 수익 배분 시스템 (V2)**의 Creditcoin Testnet 배포 결과를 기록합니다. \n본 배포는 '보유가 곧 이자(Hold to Earn)' 및 '복리 재투자(Auto-Compounding)' 모델을 구현한 `YieldDistributor(v2)`와 `BondToken(v2)`의 통합을 포함합니다.\n\n## 2. 배포 정보\n*   **Date**: 2026-01-16\n*   **Network**: Creditcoin Testnet (Chain ID: `102031`)\n*   **Script**: `contracts/scripts/redeploy_v2.ts`\n\n## 3. 배포된 컨트랙트 (Deployed Contracts)\n\n| 컨트랙트명 (New V2) | 주소 (Address) | 변경 사항 |\n|:---:|:---:|---|\n| **MockUSDC** | `0x97A41Ff77f70e9328A20b62b393F8Fb0E7e49364` | Clean Slate 배포 (초기화됨) |\n| **BondToken (v2)** | `0x6aaEe229EB0f59dC0F4B579B4E5d35E05A6846Bb` | `onBalanceChange` 훅 추가 (YieldDistributor 연동) |\n| **LiquidityPool** | `0x290adf245E805D24DF630A01843b3C3Fb20bd082` | V2 BondToken 및 USDC 주소 바인딩 |\n| **YieldDistributor (v2)** | `0xEbBa8Cec7Dee65bE9263e6378b33EC6D6Dba1308` | 멀티 채권 지원, 보유량 기반 정산, 자동 재투자(`reinvest`) 구현 |\n\n## 4. 시스템 설정 및 권한 (Configuration & Roles)\n\n### 4.1 상호 연결 (Linking)\n*   **BondToken** → **YieldDistributor**: `setYieldDistributor()` 호출 완료. (토큰 이동 시 정산소에 자동 통지)\n*   **YieldDistributor** → **BondToken**: `setBondToken()` 호출 완료.\n*   **YieldDistributor** → **LiquidityPool**: `setLiquidityPool()` 호출 완료. (재투자 시 자금 이동 경로 확보)\n\n### 4.2 권한 부여 (Role Grants)\n1.  **LiquidityPool**:\n    *   `MINTER_ROLE` on `BondToken` (User Purchase 시 토큰 발행 권한)\n2.  **YieldDistributor**:\n    *   `MINTER_ROLE` on `BondToken` (**Reinvest** 실행 시 보상을 원금으로 전환하여 추가 발행할 권한)\n\n## 5. 주요 기능 검증 (Verification)\n*   `YieldDistributorV2.test.ts` 통합 테스트 통과.\n*   **Hold to Earn**: 채권 구매 즉시 별도 스테이킹 없이 이자 발생 확인.\n*   **Reinvest**: 이자(USDC)가 시스템(LiquidityPool)으로 반환되고, 사용자에게는 등가(1:1 Peg)의 채권이 추가 발행됨을 확인.\n\n## 6. 프론트엔드 업데이트\n*   `frontend/app/config/contracts.ts`에 위 주소 반영 완료.\n"
  },
  {
    "source": "reports/18_project_review_report.md",
    "content": "# BuildCTC 프로젝트 종합 검토 보고서\n\n**검토 일자**: 2026-01-16  \n**프로젝트명**: BuildCTC (RWA Yield Protocol)  \n**현재 상태**: Phase 2 진행 중 (핵심 기능 구현 완료, V2 시스템 배포 완료)\n\n---\n\n## 1. 프로젝트 개요\n\n### 1.1 프로젝트 목적\n- **RWA Yield Protocol**: 실물 자산(태국 소상공인 대출 채권)을 ERC-1155 토큰으로 토큰화\n- **수익 배분**: 대출 이자 수익을 투자자에게 자동 배분\n- **크로스체인 접근성**: Creditcoin Gateway를 통한 다중 체인 지원\n\n### 1.2 기술 스택\n- **Smart Contracts**: Solidity ^0.8.20, Hardhat, OpenZeppelin\n- **Frontend**: React Router v7, Vite, Tailwind CSS v4, shadcn/ui, wagmi/viem\n- **Database**: Turso (SQLite), Drizzle ORM\n- **Blockchain**: Creditcoin Testnet (Chain ID: 102031)\n\n---\n\n## 2. 아키텍처 검토\n\n### 2.1 스마트 컨트랙트 구조 ✅\n\n#### 배포된 컨트랙트 (Creditcoin Testnet)\n1. **MockUSDC** (`0x97A41Ff77f70e9328A20b62b393F8Fb0E7e49364`)\n   - ERC-20 테스트 토큰 (Faucet 기능 포함)\n   - 상태: 정상\n\n2. **BondToken (v2)** (`0x6aaEe229EB0f59dC0F4B579B4E5d35E05A6846Bb`)\n   - ERC-1155 기반 채권 토큰\n   - `onBalanceChange` 훅을 통한 YieldDistributor 자동 연동\n   - AccessControl (MINTER_ROLE, URI_SETTER_ROLE)\n   - 상태: 정상\n\n3. **LiquidityPool** (`0x290adf245E805D24DF630A01843b3C3Fb20bd082`)\n   - USDC 예치 및 채권 구매(`purchaseBond`) 관리\n   - 관리자 인출 기능\n   - ReentrancyGuard 적용\n   - 상태: 정상\n\n4. **YieldDistributor (v2)** (`0xEbBa8Cec7Dee65bE9263e6378b33EC6D6Dba1308`)\n   - Synthetix 스타일 `rewardPerToken` 알고리즘\n   - 보유량 기반 자동 정산 (Hold to Earn)\n   - 복리 재투자(`reinvest`) 기능\n   - 멀티 채권 지원\n   - 상태: 정상\n\n#### 컨트랙트 간 연동\n- ✅ BondToken ↔ YieldDistributor: 훅 기반 자동 연동\n- ✅ YieldDistributor → LiquidityPool: 재투자 시 자금 이동 경로 확보\n- ✅ 권한 설정: LiquidityPool과 YieldDistributor에 MINTER_ROLE 부여 완료\n\n### 2.2 프론트엔드 구조 ✅\n\n#### 라우트 구성\n- `/` (home.tsx): 대시보드 (포트폴리오 요약, 주요 지표)\n- `/bonds`: 채권 마켓 (검색, 필터링, 투자)\n- `/portfolio`: 포트폴리오 상세 (차트, 투자 리스트)\n- `/settings`: 설정 페이지\n- `/admin`: 관리자 포털\n- `/ai-guide`: AI 가이드 어시스턴트\n\n#### 주요 특징\n- React Router v7 Framework 패턴 준수\n- wagmi/viem을 통한 Web3 연동\n- shadcn/ui 컴포넌트 시스템\n- Tailwind CSS v4 스타일링\n\n### 2.3 데이터베이스 구조 ✅\n\n#### 스키마 (Drizzle ORM)\n- `bonds`: 채권 정보 (온체인 ID, 차입자, 지역, 금액, 이자율, 만기일)\n- `investors`: 투자자 정보 (지갑 주소, KYC 상태, 자동 재투자 설정)\n- `investments`: 투자 내역 (토큰 수량, USDC 금액, 트랜잭션 해시)\n- `yield_distributions`: 수익 배분 내역\n- `repayments`: 상환 내역 (Oracle 요청 ID 포함)\n- `user`, `session`, `account`, `verification`: Better Auth 관련\n\n#### 데이터 무결성\n- 외래키 관계 설정 완료\n- 타임스탬프 필드 관리\n- Enum 타입을 통한 상태 관리\n\n---\n\n## 3. 강점 (Strengths)\n\n### 3.1 기술적 강점\n1. **명확한 아키텍처 분리**\n   - 스마트 컨트랙트, 프론트엔드, 데이터베이스 계층 명확히 분리\n   - 역할 기반 권한 관리 (AccessControl)\n\n2. **보안 고려사항**\n   - ReentrancyGuard 적용\n   - OpenZeppelin 표준 컨트랙트 사용\n   - AccessControl을 통한 권한 관리\n\n3. **최신 기술 스택**\n   - React Router v7 Framework\n   - Tailwind CSS v4\n   - TypeScript 전면 적용\n   - Drizzle ORM (타입 안전성)\n\n4. **V2 시스템 개선**\n   - Hold to Earn 모델 (별도 스테이킹 불필요)\n   - 자동 재투자(복리) 기능\n   - 실시간 정산 시스템\n\n### 3.2 프로젝트 관리 강점\n1. **체계적인 문서화**\n   - AGENTS.md 표준 준수\n   - 단계별 리포트 관리 (`docs/reports/`)\n   - 명확한 문서 계층 구조\n\n2. **배포 상태 관리**\n   - 컨트랙트 주소 중앙 관리 (`frontend/app/config/contracts.ts`)\n   - 배포 결과 문서화\n\n---\n\n## 4. 개선 필요 사항 (Issues & Recommendations)\n\n### 4.1 보안 이슈 ⚠️\n\n#### Critical\n1. **환경 변수 관리 검증 필요**\n   - `.gitignore`에 `.env*` 패턴 포함 확인 ✅\n   - 그러나 `.env.development`, `.env.production` 패턴은 명시적으로 확인 필요\n   - 실제 환경 변수 파일이 존재하는지, 민감한 정보가 커밋되지 않았는지 검증 필요\n\n2. **컨트랙트 테스트 커버리지**\n   - `YieldDistributorV2.test.ts` 존재 확인 ✅\n   - 전체 테스트 스위트 실행 및 커버리지 리포트 필요\n   - 경계 조건 테스트 추가 권장\n\n3. **권한 관리 검증**\n   - DEFAULT_ADMIN_ROLE 보유자 지갑 분리 권장\n   - 멀티시그 지갑 도입 검토\n\n#### Medium\n4. **에러 처리 개선**\n   - 프론트엔드에서 트랜잭션 실패 시 사용자 피드백 개선\n   - Toast 알림 시스템 활용 (`sonner` 패키지 설치 확인 ✅)\n\n### 4.2 기능 완성도\n\n#### High Priority\n1. **오라클 연동 미완성**\n   - `OracleAdapter.sol` 미구현\n   - Creditcoin Universal Oracle 연동 필요\n   - 상환 데이터 자동 동기화 시스템 구축\n\n2. **프론트엔드-블록체인 연동 버그 수정** ⚠️\n   - **구현 완료**: `purchaseBond`, `claimYield`, `reinvest`, `balanceOfBatch` 등 실제 컨트랙트 호출 구현됨 ✅\n   - **발견된 버그**:\n     - `portfolio.tsx`의 `earned` 함수 호출 시 `bondId` 파라미터 누락\n       - 컨트랙트: `earned(address account, uint256 bondId)`\n       - 현재: `args: [address]`만 전달\n     - `portfolio.tsx`의 `claimYield` 호출 시 `bondId` 파라미터 누락\n       - 컨트랙트: `claimYield(uint256 bondId)`\n       - 현재: `args` 없이 호출\n\n3. **리저브 풀 미구현**\n   - `ReservePool.sol` 미구현 (문서에만 존재)\n   - 디폴트 손실 보상 메커니즘 필요\n\n#### Medium Priority\n4. **백엔드 API 미구축**\n   - `backend/` 디렉토리 구조만 존재 (실제 구현 없음)\n   - 채권 데이터 CRUD API 필요\n   - Oracle 데이터 수집 서비스 필요\n\n5. **KYC/AML 시스템 미구현**\n   - 데이터베이스 스키마에 필드만 존재\n   - 실제 KYC 검증 프로세스 필요\n\n### 4.3 코드 품질\n\n#### 개선 권장 사항\n1. **테스트 코드**\n   - `contracts/package.json`에 테스트 스크립트 미설정\n   - `\"test\": \"hardhat test\"` 스크립트 추가 권장\n\n2. **타입 안전성**\n   - 프론트엔드에서 컨트랙트 ABI 타입 생성 (`typechain`) 활용 검토\n   - 현재 수동으로 ABI 정의\n\n3. **에러 바운더리**\n   - React 에러 바운더리 미구현\n   - 글로벌 에러 핸들링 필요\n\n### 4.4 문서화\n\n#### 추가 필요 문서\n1. **API 문서**\n   - 백엔드 API 엔드포인트 명세서\n   - (백엔드 구축 후)\n\n2. **배포 가이드**\n   - 프로덕션 배포 절차\n   - 환경 변수 설정 가이드\n   - 컨트랙트 업그레이드 전략\n\n3. **보안 감사 리포트**\n   - 보안 감사 수행 후 결과 문서화 필요\n\n---\n\n## 5. 기술 부채 (Technical Debt)\n\n### 5.1 현재 상태\n1. **Mock 데이터 의존**\n   - 프론트엔드에서 실제 블록체인 데이터 연동 전 Mock 데이터 사용\n   - 채권 목록, 포트폴리오 데이터 등\n\n2. **하드코딩된 컨트랙트 주소**\n   - `contracts.ts`에 주소 직접 입력\n   - 네트워크별 동적 설정 필요\n\n3. **환경 변수 관리 미완성**\n   - `.env.development`, `.env.production` 파일 존재 여부 불명확\n   - 환경별 설정 분리 필요\n\n### 5.2 리팩토링 권장 사항\n1. **컨트랙트 주소 관리 개선**\n   - 환경 변수 또는 설정 파일 기반 주소 관리\n   - 네트워크별 자동 전환\n\n2. **타입 생성 자동화**\n   - Hardhat의 `typechain` 플러그인 활용\n   - 프론트엔드에서 자동 생성된 타입 사용\n\n---\n\n## 6. 프로젝트 진행 상태\n\n### 6.1 완료된 항목 ✅\n- [x] 프로젝트 구조 설정\n- [x] 스마트 컨트랙트 개발 (BondToken, LiquidityPool, YieldDistributor v2)\n- [x] Creditcoin Testnet 배포\n- [x] 컨트랙트 통합 테스트\n- [x] 프론트엔드 기본 구조 및 UI 컴포넌트\n- [x] 데이터베이스 스키마 설계 및 마이그레이션\n- [x] 문서화 기본 구조\n\n### 6.2 진행 중 항목 🚧\n- [ ] 프론트엔드-블록체인 연동 (부분 완료)\n- [ ] 오라클 연동 (설계 단계)\n- [ ] 백엔드 API 개발 (미시작)\n\n### 6.3 미시작 항목 ❌\n- [ ] 리저브 풀 구현\n- [ ] Gateway 통합 (크로스체인)\n- [ ] KYC/AML 시스템\n- [ ] 보안 감사\n- [ ] 프로덕션 배포 준비\n\n---\n\n## 7. 즉시 조치 사항 (Immediate Actions)\n\n### Critical (즉시 처리)\n1. **환경 변수 보안 검증**\n   - `.env*` 파일이 Git에 커밋되지 않았는지 확인\n   - `git log --all --full-history -- \"*.env*\"` 명령어로 검증\n   - 필요 시 `git filter-branch` 또는 BFG Repo-Cleaner 사용\n\n2. **테스트 스크립트 설정**\n   - `contracts/package.json`에 테스트 스크립트 추가\n\n3. **프론트엔드-블록체인 연동 우선순위 작업**\n   - `purchaseBond` 함수 호출 구현\n   - `claimYield` 함수 호출 구현\n\n### High Priority (1주일 내)\n4. **오라클 연동 설계 및 구현**\n   - OracleAdapter 컨트랙트 설계\n   - 백엔드 Oracle 서비스 구축\n\n5. **백엔드 API 기본 구조 구축**\n   - Express.js/Fastify 또는 FastAPI 설정\n   - 기본 CRUD 엔드포인트 구현\n\n---\n\n## 8. 향후 로드맵 제안\n\n### Phase 3: 오라클 및 백엔드 (예상 2-3주)\n- OracleAdapter 컨트랙트 구현\n- 백엔드 Oracle 데이터 수집 서비스\n- 기본 REST API 구축\n\n### Phase 4: 리스크 관리 (예상 1-2주)\n- ReservePool 컨트랙트 구현\n- 디폴트 감지 및 처리 로직\n\n### Phase 5: 보안 및 최적화 (예상 2-3주)\n- 보안 감사\n- 가스 최적화\n- 컨트랙트 업그레이드 전략 수립\n\n### Phase 6: 프로덕션 준비 (예상 2-3주)\n- KYC/AML 통합\n- 모니터링 시스템 구축\n- 메인넷 배포\n\n---\n\n## 9. 결론\n\n### 전반적인 평가\nBuildCTC 프로젝트는 **견고한 아키텍처**와 **명확한 비즈니스 모델**을 가지고 있습니다. V2 시스템 배포를 통해 핵심 기능의 기술적 구현이 완료되었으며, 프론트엔드 기본 구조도 잘 갖춰져 있습니다.\n\n### 주요 강점\n- ✅ 명확한 코드 구조와 분리\n- ✅ 최신 기술 스택 활용\n- ✅ 체계적인 문서화\n- ✅ 보안 고려사항 반영 (ReentrancyGuard, AccessControl)\n\n### 주요 개선 필요 사항\n- ⚠️ 프론트엔드-블록체인 실제 연동\n- ⚠️ 오라클 연동 구현\n- ⚠️ 백엔드 API 구축\n- ⚠️ 보안 감사 및 테스트 커버리지 향상\n\n### 권장 사항\n프로젝트가 **Phase 2에서 Phase 3로 전환**되는 시점입니다. 다음 마일스톤인 오라클 연동과 백엔드 구축에 집중하여 실제 작동하는 MVP를 완성하는 것이 중요합니다. 동시에 보안 감사와 테스트 커버리지 향상을 병행하여 프로덕션 준비를 진행하는 것을 권장합니다.\n\n---\n\n**검토자**: AI Assistant  \n**다음 검토 일자**: Phase 3 완료 후 또는 주요 이정표 달성 시"
  },
  {
    "source": "reports/19_critical_fixes_verification.md",
    "content": "# 19. Critical Fixes Verification Report\n\n**검증 일자**: 2026-01-16  \n**검증 범위**: Critical 버그 수정 및 인프라 설정 점검\n\n---\n\n## 1. 수정 항목 검증\n\n### 1.1 프론트엔드 버그 수정 ✅\n\n#### 수정 파일\n- `frontend/app/routes/portfolio.tsx`\n\n#### 수정 내용\n\n**1. `earned` 함수 호출 수정**\n```typescript\n// 수정 전 (버그)\nargs: address ? [address] : undefined\n\n// 수정 후 (정상)\nargs: address ? [address, BigInt(1)] : undefined\n```\n- **위치**: 41번째 줄\n- **상태**: ✅ 수정 완료\n- **컨트랙트 시그니처**: `earned(address account, uint256 bondId)`\n\n**2. `claimYield` 함수 호출 수정**\n```typescript\n// 수정 전 (버그)\nclaimYield({\n    functionName: \"claimYield\",\n    // args 없음\n});\n\n// 수정 후 (정상)\nclaimYield({\n    functionName: \"claimYield\",\n    args: [BigInt(1)],\n});\n```\n- **위치**: 62번째 줄\n- **상태**: ✅ 수정 완료\n- **컨트랙트 시그니처**: `claimYield(uint256 bondId)`\n\n#### 검증 결과\n- ✅ `bondId` 파라미터가 정상적으로 추가됨\n- ✅ 컨트랙트 시그니처와 일치\n- ✅ 현재는 Bond ID 1에 대한 summary 표시로 `BigInt(1)` 사용 (의도된 동작)\n- ℹ️ 각 투자별 `earned`/`claim`은 `InvestmentList` 컴포넌트에서 이미 올바르게 구현됨 (각 `inv.id` 사용)\n\n### 1.2 인프라 설정 ✅\n\n#### 수정 파일\n- `contracts/package.json`\n\n#### 수정 내용\n\n**테스트 스크립트 추가**\n```json\n{\n  \"scripts\": {\n    \"test\": \"hardhat test\"\n  }\n}\n```\n- **위치**: 7번째 줄\n- **상태**: ✅ 추가 완료\n\n#### 검증 결과\n- ✅ 스크립트 추가 확인\n- ✅ `npm test` 명령어 실행 테스트 완료 (hardhat test 정상 실행)\n- ⚠️ Node.js v25.2.1 사용 중 (Hardhat 지원 버전 아님) - 경고 발생하지만 동작은 정상\n\n---\n\n## 2. 환경 변수 보안 검증 ✅\n\n### 2.1 .gitignore 설정 확인\n\n**.gitignore 파일 검증**:\n```\n.env\n.env*\n.env.local\n.env.development.local\n.env.test.local\n.env.production.local\n.env*.local\ncontracts/.env\n```\n\n**검증 결과**:\n- ✅ `.env*` 패턴이 `.gitignore`에 포함되어 있음\n- ✅ `contracts/.env`도 명시적으로 제외됨\n- ✅ 모든 환경 변수 파일 패턴이 커버됨\n\n### 2.2 Git 히스토리 검증\n\n**과거 커밋 이력 확인**:\n```\ncommit cea683db - docs(management): 문서 계층 구조 정리...\ncommit 53305bee - chore(git): 민감한 파일 및 불필요한 node_modules 제거\n  - contracts/.env 파일 Git 추적 제외 (보안 조치)\n```\n\n**검증 결과**:\n- ✅ 과거에 `.env` 파일이 커밋된 적이 있었지만\n- ✅ `53305bee` 커밋에서 이미 제거 조치 완료\n- ✅ 현재 Git에서 추적되지 않음\n\n### 2.3 현재 파일 시스템 확인\n\n**실제 존재하는 .env 파일**:\n```\n./frontend/.env.production\n./frontend/.env.example\n./frontend/.env.development\n./contracts/.env\n```\n\n**검증 결과**:\n- ✅ 모든 `.env*` 파일이 `.gitignore`에 의해 Git 추적에서 제외됨\n- ✅ `git status`에서 나타나지 않음 확인\n- ✅ 보안 정책 준수\n\n---\n\n## 3. 추가 검증 사항\n\n### 3.1 관련 컴포넌트 확인\n\n**`InvestmentList` 컴포넌트 (`investment-list.tsx`)**:\n- ✅ `earned` 함수: `args: [address, BigInt(inv.id)]` - 올바르게 구현됨 (25번째 줄)\n- ✅ `claimYield` 함수: `args: [BigInt(inv.id)]` - 올바르게 구현됨 (70번째 줄)\n- ✅ 각 투자별로 올바른 `bondId` 사용\n\n### 3.2 코드 일관성 확인\n\n**컨트랙트 시그니처와의 일치성**:\n- ✅ `YieldDistributor.earned(address account, uint256 bondId)` ← `portfolio.tsx` line 41 일치\n- ✅ `YieldDistributor.claimYield(uint256 bondId)` ← `portfolio.tsx` line 62 일치\n- ✅ `InvestmentList`에서도 모든 호출이 올바름\n\n---\n\n## 4. 발견 사항 및 권장 사항\n\n### 4.1 현재 구현 상태 ✅\n\n**포트폴리오 페이지 구조**:\n- **Summary 레벨** (`portfolio.tsx`): Bond ID 1에 대한 전체 수익 summary 표시\n  - 현재 `BigInt(1)` 하드코딩은 의도된 동작으로 보임\n- **Detail 레벨** (`InvestmentList`): 각 투자별 개별 `earned`/`claim` 처리\n  - 각 `inv.id`를 사용하여 올바르게 구현됨\n\n**권장사항** (선택사항):\n- `portfolio.tsx`의 `BigInt(1)`을 변수로 추출하여 명확성 향상 가능\n- 여러 채권에 대한 aggregate summary가 필요한 경우 로직 개선 검토\n\n### 4.2 Node.js 버전 경고 ⚠️\n\n**현재 상태**:\n- Node.js v25.2.1 사용 중\n- Hardhat은 Node.js 18.x, 20.x를 공식 지원\n- 경고가 발생하지만 테스트는 정상 동작\n\n**권장사항**:\n- 프로덕션 환경에서는 Node.js 20.x LTS 사용 권장\n- `.nvmrc` 또는 `package.json`의 `engines` 필드로 버전 명시\n\n### 4.3 환경 변수 파일 관리 ✅\n\n**현재 상태**:\n- `.env*` 파일들이 모두 `.gitignore`에 의해 보호됨\n- `.env.example` 파일은 존재하지만 Git 추적되지 않음\n\n**권장사항**:\n- `.env.example` 파일은 템플릿으로 Git에 포함시켜 팀원들이 참고할 수 있도록 함\n- 실제 민감한 정보는 포함하지 않고 변수명만 명시\n\n---\n\n## 5. 검증 완료 체크리스트\n\n### Critical 수정 사항\n- [x] `portfolio.tsx`의 `earned` 함수에 `bondId` 파라미터 추가\n- [x] `portfolio.tsx`의 `claimYield` 함수에 `bondId` 파라미터 추가\n- [x] 컨트랙트 시그니처와 일치 여부 확인\n\n### 인프라 설정\n- [x] `contracts/package.json`에 테스트 스크립트 추가\n- [x] 테스트 명령어 실행 확인\n- [x] 환경 변수 파일 Git 추적 제외 확인\n- [x] Git 히스토리에서 민감한 정보 누출 여부 확인\n\n### 코드 품질\n- [x] Linter 오류 없음\n- [x] 관련 컴포넌트 일관성 확인\n\n---\n\n## 6. 결론\n\n### 검증 결과 요약\n\n**✅ Critical 버그 수정 완료**\n- `portfolio.tsx`의 `earned` 및 `claimYield` 함수 호출이 정상적으로 수정됨\n- 컨트랙트 시그니처와 완벽히 일치\n\n**✅ 인프라 설정 완료**\n- 테스트 스크립트 추가 및 동작 확인\n- 환경 변수 보안 정책 준수 확인\n\n**⚠️ 권장 사항**\n- Node.js 버전을 Hardhat 지원 버전(20.x LTS)으로 조정 검토\n- `.env.example` 파일을 템플릿으로 Git에 포함 검토\n\n### 다음 단계\n- [ ] Node.js 버전 관리 (선택사항)\n- [ ] `.env.example` 파일 템플릿화 (선택사항)\n- [ ] 실제 테스트 실행 및 결과 검증 (프로젝트 진행 시)\n\n---\n\n**검증자**: AI Assistant  \n**검증 완료 일자**: 2026-01-16"
  },
  {
    "source": "roadmap/13_impact_visualization_spec.md",
    "content": "# 13. Impact Visualization & ESG Data Specification\n\n## 1. 개요 (Overview)\nBuildCTC는 실물 자산(RWA) 기반의 투자 플랫폼입니다. 사용자가 자신의 투자가 실제로 어디에서(Where) 사용되고, 어떤 긍정적인 영향(What Impact)을 미치는지 체감할 수 있도록 하는 것은 플랫폼의 신뢰도와 사용자 경험(UX)에 결정적입니다.\n본 문서는 Google Maps API를 활용한 **지리적 시각화**와 **ESG(환경·사회·지배구조) 임팩트 데이터**를 표현하기 위한 기술 명세를 정의합니다.\n\n## 2. 주요 기능 및 목표 (Key Features & Goals)\n\n### 2.1 인터랙티브 임팩트 맵 (Interactive Impact Map)\n*   **목표**: 투자 상품(채권)의 물리적 위치를 지도상에 핀(Marker)으로 표시하여 실체성(Tangibility)을 강조.\n*   **기능**:\n    *   Google Maps 연동.\n    *   클러스터링(Clustering): 여러 투자가 밀집된 지역 그룹화.\n    *   정보 창(Info Window): 핀 클릭 시 해당 투자의 요약 정보(이미지, 수익률, 제목) 표시.\n\n### 2.2 ESG 임팩트 대시보드 (ESG Dashboard)\n*   **목표**: 단순한 금전적 수익(ROI)을 넘어 사회적 기여도를 수치화하여 표시.\n*   **지표 예시**:\n    *   🌱 탄소 배출 감소량 (Carbon Offset)\n    *   👥 일자리 창출 수 (Jobs Created)\n    *   🏢 소상공인 지원 수 (SMEs Supported)\n\n### 2.3 프로젝트 스토리텔링 (Storytelling)\n*   **목표**: 차갑고 딱딱한 금융 데이터에 인간적인 서사를 부여.\n*   **콘텐츠**: 현장 사진, 수혜자 인터뷰 영상, 프로젝트 진행 현황 타임라인.\n\n## 3. 기술 아키텍처 (Technical Architecture)\n\n### 3.1 기술 스택\n*   **Map Provider**: `@vis.gl/react-google-maps` (React 최적화 라이브러리)\n*   **Data Visualization**: `recharts` (기존 라이브러리 활용)\n*   **Frontend**: React Router v7 components\n\n### 3.2 데이터 모델 (Data Schema)\n\n#### BondLocation (위치 정보)\n```typescript\ninterface BondLocation {\n    bondId: string;\n    latitude: number;\n    longitude: number;\n    address: string;\n    city: string;\n    country: string;\n}\n```\n\n#### ImpactMetrics (임팩트 지표)\n```typescript\ninterface ImpactMetric {\n    bondId: string;\n    category: 'Environment' | 'Social' | 'Governance';\n    label: string;      // e.g., \"CO2 Reduced\"\n    value: number;\n    unit: string;       // e.g., \"tons\", \"jobs\"\n    description?: string;\n}\n```\n\n## 4. 구현 상세 (Implementation Details)\n\n### 4.1 Google Maps 설정\n1.  **API Key 발급**: Google Cloud Platform(GCP)에서 Maps JavaScript API 활성화 및 키 발급. (환경변수 `VITE_GOOGLE_MAPS_API_KEY`로 관리)\n2.  **컴포넌트 구조**:\n    ```tsx\n    // components/impact/impact-map.tsx\n    <APIProvider apiKey={import.meta.env.VITE_GOOGLE_MAPS_API_KEY}>\n        <Map center={...} zoom={...}>\n            {bonds.map(bond => (\n                <AdvancedMarker position={...} onClick={...} />\n            ))}\n        </Map>\n    </APIProvider>\n    ```\n\n### 4.2 화면 구성 계획\n*   **진입점**: `/portfolio` (상단 탭 또는 별도 섹션) 또는 `/bonds` (탐색형 지도).\n*   **UI 레이아웃**:\n    *   좌측/배경: 지도 (Map View)\n    *   Overlay: 선택된 지역의 ESG 스코어카드 및 프로젝트 리스트 카드.\n\n## 5. 단계별 구현 계획 (Phased Plan)\n\n### Phase 1: 기본 지도 연동 (Basic Map)\n*   [ ] `@vis.gl/react-google-maps` 설치.\n*   [ ] Google Maps API 키 발급 및 `.env` 설정.\n*   [ ] `ImpactMap` 컴포넌트 생성 및 더미 좌표 데이터(Mock Data) 렌더링.\n\n### Phase 2: 정보 연결 (Interaction)\n*   [ ] 마커 클릭 시 해당 채권의 상세 모달(Invest Modal) 연동.\n*   [ ] `bonds.tsx`의 리스트와 지도 마커 상호 연동 (리스트 호버 시 지도 강조 등).\n\n### Phase 3: ESG 데이터 시각화 (Advanced)\n*   [ ] `ImpactMetrics` 데이터 구조 정의 및 차트 컴포넌트 구현.\n*   [ ] 포트폴리오 페이지에 '나의 임팩트(My Impact)' 섹션 추가 (내가 투자한 프로젝트들의 ESG 합계).\n\n## 6. 필요 리소스\n*   Google Maps API Key (Google Cloud Platform Billing 등록 필요).\n*   Mock Data: 태국(방콕, 라용), 나이지리아 등 주요 RWA 타겟 지역의 실제 위경도 좌표.\n"
  },
  {
    "source": "roadmap/14_oracle_integration_architecture.md",
    "content": "# 14. Oracle Integration Architecture\n\n## 1. 개요 (Overview)\nBuildCTC는 실물 자산(RWA, Real World Assets)을 블록체인 상으로 가져와 투자 상품화하는 플랫폼입니다. 블록체인 외부(Off-chain)에 존재하는 실제 자산의 상태(상환 여부, 성과, 신용 등급 등)를 블록체인 내부(On-chain)의 스마트 컨트랙트가 신뢰할 수 있게 검증하고 가져오기 위해서는 **오라클(Oracle)** 시스템이 필수적입니다.\n본 문서는 **Creditcoin Universal Oracle**을 활용한 데이터 연동 아키텍처를 정의합니다.\n\n## 2. 목표 (Goals)\n1.  **데이터 무결성(Integrity)**: 외부 데이터가 스마트 컨트랙트로 전달되는 과정에서 변조되지 않았음을 보장.\n2.  **자동화(Automation)**: 채무자의 상환 내역이나 자산 가치 변동이 자동으로 컨트랙트에 반영되어 수익 배분 등을 트리거.\n3.  **투명성(Transparency)**: 오라클을 통해 가져온 모든 데이터와 그 출처를 온체인에 기록하여 누구나 검증 가능하게 함.\n\n## 3. 오라클 아키텍처 (Architecture)\n\n### 3.1 전체 흐름 (Data Flow)\n```mermaid\nsequenceDiagram\n    participant RealWorld as Off-chain Source (Fintech API)\n    participant OracleNode as Oracle Node (Gateway)\n    participant BuildCTCOracle as Oracle Adapter Contract\n    participant BuildCTCCore as Core Contracts (Bond/Yield)\n\n    RealWorld->>OracleNode: 1. Asset Performance Data (Repayment)\n    OracleNode->>OracleNode: 2. Verify & Sign Data\n    OracleNode->>BuildCTCOracle: 3. Submit Transaction (updateAssetStatus)\n    BuildCTCOracle->>BuildCTCCore: 4. Hook / Callback\n    BuildCTCCore->>BuildCTCCore: 5. Execute Logic (e.g., Distribute Yield)\n```\n\n### 3.2 주요 컴포넌트\n\n#### A. Off-chain Data Source (Fintech Partner API)\n*   실제 대출/투자 집행 기관(핀테크 파트너)의 ERP 또는 API 시스템.\n*   **Provision Data**:\n    *   `loan_id`: 대출 고유 식별자.\n    *   `repayment_amount`: 상환된 원리금.\n    *   `repayment_date`: 상환 일시.\n    *   `status`: 정상(Normal), 연체(Overdue), 부도(Default).\n\n#### B. Oracle Node (Gateway Service)\n*   **Creditcoin Universal Oracle Gateway** 역할 수행.\n*   주기적으로(Polling) 또는 Webhook 방식으로 파트너 API의 데이터를 수집.\n*   데이터를 표준화된 포맷으로 변환하고 자신의 개인키(Oracle Private Key)로 서명하여 온체인 트랜잭션 생성.\n*   **구현 기술**: Node.js/NestJS 또는 Go (Serverless Functions 권장).\n\n#### C. Oracle Adapter Contract (`OracleAdapter.sol`)\n*   오라클 노드로부터 데이터를 수신하는 스마트 컨트랙트 창구.\n*   **보안 기능**:\n    *   `Trusted Oracle Registry`: 사전에 승인된 오라클 주소(Address)로부터 온 트랜잭션만 허용.\n    *   `Events`: 데이터 업데이트 시 `AssetStatusUpdated` 이벤트 발생.\n    *   `Interface`: `IOracleAdapter.sol` 인터페이스 제공.\n\n## 4. 데이터 모델 (On-chain Data Structure)\n\n### 4.1 Asset Snapshot\n스마트 컨트랙트에 기록될 자산 상태 구조체입니다.\n```solidity\nstruct AssetPerformance {\n    uint256 timestamp;      // 업데이트 시각\n    uint256 principalPaid;  // 상환된 원금 누적액\n    uint256 interestPaid;   // 상환된 이자 누적액\n    uint8 status;           // 0: Active, 1: Repaid, 2: Default\n    string verifyProof;     // 외부 검증 증명 (IPFS Hash 등)\n}\n```\n\n## 5. 단계별 구현 계획 (Implementation Phases)\n\n### Phase 1: 오라클 어댑터 초안 (Mock Oracle)\n*   개발 및 테스트 목적의 단순화된 오라클.\n*   **`MockOracle.sol`**:\n    *   `setAssetData(uint256 bondId, uint256 amount)` 함수로 누구나(또는 Admin만) 데이터 주입 가능.\n    *   프론트엔드 및 YieldDistributor 로직 테스트용.\n\n### Phase 2: Trusted Oracle Adapter\n*   **`OracleAdapter.sol`**:\n    *   AccessControl 도입 (`ORACLE_ROLE`).\n    *   실제 `YieldDistributor` 컨트랙트가 이 어댑터를 참조하여 수익 배분 가능 여부를 판단하도록 연결.\n\n### Phase 3: 백엔드 게이트웨이 구축\n*   핀테크 파트너의 Mock API 서버 구축.\n*   이를 주기적으로 체크하여 `OracleAdapter`의 `updateData`를 호출하는 **Relayer Bot** 개발.\n\n## 6. 현재 구현 상태 (Current Implementation Status)\n\n### 6.1 스마트 컨트랙트\n#### 구현 완료 ✅\n- ✅ `BondToken.sol` (v2)\n- ✅ `LiquidityPool.sol`\n- ✅ `YieldDistributor.sol` (v2) - `depositYield(uint256 bondId, uint256 amount)` 함수 존재\n- ✅ `MockUSDC.sol`\n\n#### 미구현 ❌\n- ❌ `MockOracle.sol` (Phase 1)\n- ❌ `OracleAdapter.sol` (Phase 2)\n- ❌ `IOracleAdapter.sol` (인터페이스)\n\n### 6.2 백엔드 서비스\n- ❌ Oracle Node (Gateway Service)\n- ❌ Fintech Partner Mock API\n- ❌ Relayer Bot\n- ❌ Creditcoin Universal Oracle 통합\n\n## 7. YieldDistributor 연동 상세 (Integration Details)\n\n### 7.1 현재 YieldDistributor 구조\n현재 `YieldDistributor.sol`은 이미 오라클과의 연동을 지원할 수 있는 구조입니다:\n```solidity\nfunction depositYield(uint256 bondId, uint256 amount) external \n    nonReentrant onlyRole(DISTRIBUTOR_ROLE) {\n    // 자동으로 rewardPerTokenStored 업데이트\n    // 사용자별 수익 계산 및 저장\n}\n```\n\n### 7.2 OracleAdapter → YieldDistributor 연동 방법\n\n**권장 방식: 직접 호출 (Option 1)**\n```solidity\n// OracleAdapter.sol\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./YieldDistributor.sol\";\n\ncontract OracleAdapter is AccessControl {\n    bytes32 public constant ORACLE_ROLE = keccak256(\"ORACLE_ROLE\");\n    YieldDistributor public yieldDistributor;\n    \n    function updateAssetStatus(uint256 bondId, AssetPerformance calldata data) \n        external onlyRole(ORACLE_ROLE) {\n        require(data.interestPaid > 0, \"No interest to distribute\");\n        \n        // USDC를 YieldDistributor로 전송\n        IERC20 usdc = IERC20(yieldDistributor.usdcToken());\n        usdc.transferFrom(msg.sender, address(yieldDistributor), data.interestPaid);\n        \n        // YieldDistributor에 수익 배포 요청\n        // OracleAdapter에 DISTRIBUTOR_ROLE 부여 필요\n        yieldDistributor.depositYield(bondId, data.interestPaid);\n        \n        emit AssetStatusUpdated(bondId, data);\n    }\n}\n```\n\n**권한 설정**:\n- OracleAdapter 컨트랙트에 `YieldDistributor.DISTRIBUTOR_ROLE` 부여 필요\n- 또는 YieldDistributor가 OracleAdapter 주소를 참조하는 별도 함수 구현\n\n### 7.3 연동 시퀀스\n```mermaid\nsequenceDiagram\n    participant Oracle as Oracle Adapter\n    participant USDC as MockUSDC\n    participant Yield as Yield Distributor\n    participant Token as Bond Token\n    \n    Oracle->>USDC: transferFrom(oracle, yieldDistributor, amount)\n    Oracle->>Yield: depositYield(bondId, amount)\n    Yield->>Yield: Update rewardPerTokenStored\n    Yield->>Token: Check balances (via hook)\n    Yield-->>Oracle: Emit YieldDeposited event\n```\n\n## 8. 구체적 구현 계획 (Detailed Implementation Plan)\n\n### 8.1 Phase 1: MockOracle 구현 (1-2주)\n\n#### MockOracle.sol\n```solidity\n// contracts/contracts/MockOracle.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./YieldDistributor.sol\";\n\ncontract MockOracle is AccessControl {\n    bytes32 public constant DISTRIBUTOR_ROLE = keccak256(\"DISTRIBUTOR_ROLE\");\n    \n    YieldDistributor public yieldDistributor;\n    IERC20 public usdcToken;\n    \n    event AssetDataUpdated(uint256 indexed bondId, uint256 amount);\n    \n    constructor(address _yieldDistributor, address _usdcToken) {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(DISTRIBUTOR_ROLE, msg.sender);\n        yieldDistributor = YieldDistributor(_yieldDistributor);\n        usdcToken = IERC20(_usdcToken);\n    }\n    \n    function setAssetData(uint256 bondId, uint256 interestAmount) \n        external onlyRole(DISTRIBUTOR_ROLE) {\n        require(interestAmount > 0, \"Amount must be > 0\");\n        \n        // USDC를 YieldDistributor로 전송\n        usdcToken.transferFrom(msg.sender, address(yieldDistributor), interestAmount);\n        \n        // YieldDistributor에 수익 배포\n        yieldDistributor.depositYield(bondId, interestAmount);\n        \n        emit AssetDataUpdated(bondId, interestAmount);\n    }\n}\n```\n\n#### 테스트 요구사항\n- MockOracle에서 `depositYield` 호출 시나리오\n- 프론트엔드 Admin 패널 연동\n- 사용자 수익 배분 확인\n\n### 8.2 Phase 2: OracleAdapter 구현 (2-3주)\n\n#### OracleAdapter.sol 구조\n```solidity\n// contracts/contracts/OracleAdapter.sol\ncontract OracleAdapter is AccessControl {\n    bytes32 public constant ORACLE_ROLE = keccak256(\"ORACLE_ROLE\");\n    \n    struct AssetPerformance {\n        uint256 timestamp;\n        uint256 principalPaid;\n        uint256 interestPaid;\n        uint8 status; // 0: Active, 1: Repaid, 2: Default\n        string verifyProof; // IPFS Hash 등\n    }\n    \n    mapping(uint256 => AssetPerformance) public assetPerformances;\n    mapping(address => bool) public trustedOracles;\n    \n    YieldDistributor public yieldDistributor;\n    \n    event AssetStatusUpdated(\n        uint256 indexed bondId,\n        uint256 principalPaid,\n        uint256 interestPaid,\n        uint8 status\n    );\n    \n    function updateAssetStatus(uint256 bondId, AssetPerformance calldata data) \n        external onlyRole(ORACLE_ROLE) {\n        // 검증 로직\n        require(data.interestPaid > 0, \"No interest to distribute\");\n        require(block.timestamp >= data.timestamp, \"Invalid timestamp\");\n        \n        // 데이터 저장\n        assetPerformances[bondId] = data;\n        \n        // YieldDistributor에 수익 배포\n        IERC20 usdc = IERC20(yieldDistributor.usdcToken());\n        usdc.transferFrom(msg.sender, address(yieldDistributor), data.interestPaid);\n        yieldDistributor.depositYield(bondId, data.interestPaid);\n        \n        emit AssetStatusUpdated(bondId, data.principalPaid, data.interestPaid, data.status);\n    }\n    \n    function addTrustedOracle(address oracle) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        trustedOracles[oracle] = true;\n    }\n}\n```\n\n#### 인터페이스 정의\n```solidity\n// contracts/interfaces/IOracleAdapter.sol\ninterface IOracleAdapter {\n    struct AssetPerformance {\n        uint256 timestamp;\n        uint256 principalPaid;\n        uint256 interestPaid;\n        uint8 status;\n        string verifyProof;\n    }\n    \n    event AssetStatusUpdated(\n        uint256 indexed bondId,\n        uint256 principalPaid,\n        uint256 interestPaid,\n        uint8 status\n    );\n    \n    function updateAssetStatus(uint256 bondId, AssetPerformance calldata data) external;\n    function getAssetPerformance(uint256 bondId) \n        external view returns (AssetPerformance memory);\n}\n```\n\n### 8.3 Phase 3: 백엔드 게이트웨이 (1-2개월)\n\n#### 기술 스택\n- Node.js/TypeScript\n- Express.js 또는 FastAPI\n- viem 또는 ethers.js (블록체인 연동)\n\n#### Mock Fintech API 서버\n**엔드포인트**: `GET /api/repayments/{bondId}`\n```json\n{\n  \"bondId\": 1,\n  \"repaymentAmount\": \"1000000\",\n  \"principalAmount\": \"800000\",\n  \"interestAmount\": \"200000\",\n  \"repaymentDate\": \"2026-01-16T00:00:00Z\",\n  \"status\": \"Normal\"\n}\n```\n\n#### Oracle Node (Relayer Bot)\n- 주기적 폴링 (예: 1시간마다)\n- 데이터 검증 및 서명\n- `OracleAdapter.updateAssetStatus` 트랜잭션 제출\n- 실패 시 재시도 로직\n\n#### 환경 설정\n```env\nORACLE_PRIVATE_KEY=0x...\nRPC_URL=https://rpc.cc3-testnet.creditcoin.network\nORACLE_ADAPTER_ADDRESS=0x...\nUSDC_TOKEN_ADDRESS=0x...\n```\n\n## 9. 에러 처리 및 예외 상황 (Error Handling)\n\n### 9.1 Oracle Node 장애\n- **대응**: 다중 Oracle Node 운영 (나중에)\n- **임시**: 수동 `depositYield` 호출\n\n### 9.2 데이터 불일치\n- **검증**: `timestamp` 확인, `verifyProof` 검증\n- **롤백**: 이전 상태 유지\n\n### 9.3 가스 비용\n- Oracle Node에 충분한 ETH/CTC 보유 필요\n- 가스 가격 모니터링 및 알림\n\n## 10. 보안 고려사항 (Security Considerations)\n\n### 10.1 Oracle 주소 관리\n- Trusted Oracle Registry 화이트리스트\n- 멀티시그 고려 (향후)\n\n### 10.2 데이터 검증\n- `verifyProof` IPFS 해시 검증\n- 타임스탬프 검증\n- 금액 일관성 검증\n\n### 10.3 AccessControl\n- `ORACLE_ROLE` 엄격한 권한 관리\n- 역할 분리 (Oracle vs Admin)\n\n## 11. 구현 로드맵 (Implementation Roadmap)\n\n### Week 1-2: Phase 1 (MockOracle)\n- [ ] MockOracle.sol 구현\n- [ ] 단위 테스트 작성\n- [ ] YieldDistributor 연동 테스트\n- [ ] 프론트엔드 Admin 패널 연동\n\n### Week 3-4: Phase 2 (OracleAdapter)\n- [ ] OracleAdapter.sol 구현\n- [ ] IOracleAdapter 인터페이스 정의\n- [ ] AccessControl 및 보안 테스트\n- [ ] YieldDistributor 통합 테스트\n\n### Week 5-8: Phase 3 (Backend)\n- [ ] Mock Fintech API 서버 구축\n- [ ] Oracle Node (Relayer Bot) 개발\n- [ ] Creditcoin Universal Oracle 통합 (문서 확보 후)\n- [ ] End-to-End 테스트\n\n## 12. 결론 (Conclusion)\n오라클 연동은 BuildCTC가 단순한 토큰 놀이가 아닌 실제 금융 시스템으로 작동하게 하는 핵심입니다. \n\n**현재 상태**: 설계 완료, 구현 미시작  \n**다음 단계**: Phase 1 (MockOracle) 즉시 시작 가능\n\n초기 단계(Phase 1)에서는 `MockOracle`을 통해 빠르게 기능성을 검증하고, 점차 탈중앙화된 신뢰 모델로 고도화할 것입니다.\n"
  },
  {
    "source": "roadmap/15_risk_management_system_design.md",
    "content": "# 15. Risk Management System Design\n\n## 1. 개요 (Overview)\n금융 플랫폼, 특히 실물 자산(RWA) 기반 대출 플랫폼에서 리스크 관리는 투자자 신뢰와 지속 가능성을 위한 가장 중요한 요소입니다. 채무 불이행(Default)은 언제든 발생할 수 있으며, 이에 대한 체계적인 대비책이 시스템 레벨(Smart Contract)에서 구현되어야 합니다.\n본 문서는 **리저브 풀(Reserve Pool)**을 이용한 손실 보전 메커니즘과 디폴트 처리 프로세스를 정의합니다.\n\n## 2. 목표 (Objectives)\n1.  **투자자 보호 (Investor Protection)**: 채무 불이행 발생 시 원금의 일부 또는 전액을 보전.\n2.  **자동화된 대응 (Automated Response)**: 오라클을 통해 디폴트가 확인되면 즉시 프로토콜 레벨에서 대응 로직(보험금 지급 등) 실행.\n3.  **투명한 적립 (Transparent Funding)**: 수익의 일정 비율이 투명하게 리저브 풀로 적립되는 과정 공개.\n\n## 3. 리스크 관리 메커니즘 (Mechanism)\n\n### 3.1 리저브 풀 (Reserve Pool)\n리저브 풀은 플랫폼의 \"보험금\" 역할을 하는 스마트 컨트랙트입니다.\n\n*   **재원 마련 (Funding Source)**:\n    *   **Spread Fee**: 대출 금리와 투자자 제공 금리 사이의 차익(Spread) 중 일부(예: 10%)를 자동 적립.\n    *   **Protocol Fee**: 플랫폼 수수료의 일부 적립.\n*   **운용**: 안전 자산(USDC, Stablecoin) 형태로 보관되며, 평상시에는 출금이 제한됩니다.\n\n### 3.2 디폴트 처리 프로세스 (Default Handling Process)\n```mermaid\ngraph TD\n    A[Default Event Detect] -->|Oracle Report| B(Protocol Governance)\n    B -->|Confirm Default| C{Reserve Pool Coverage}\n    C -->|Funds Available| D[Execute Compensation]\n    C -->|Insufficient Funds| E[Pro-rata Distribute & Sell Collateral]\n    D --> F[Investor Claim]\n    E --> F\n```\n\n1.  **감지 (Detection)**: `OracleAdapter`가 특정 채권의 상태를 `Default(2)`로 업데이트.\n2.  **트리거 (Trigger)**: 상태 변경 시 `LiquidityPool` 또는 별도의 `InsuranceManager` 컨트랙트가 `processDefault(bondId)` 함수 실행.\n3.  **보상 (Compensation)**:\n    *   해당 Bond의 미상환 원금 계산.\n    *   `ReservePool`에서 가능한 범위 내에서 자금 인출.\n    *   해당 Bond 보유자(Token Holder)들에게 `USDC` 지급 (또는 청구권 토큰 발행).\n\n## 4. 스마트 컨트랙트 설계 (Smart Contract Design)\n\n### 4.1 ReservePool.sol\n```solidity\ncontract ReservePool is AccessControl, ReentrancyGuard {\n    IERC20 public usdc;\n    uint256 public totalReserves;\n\n    // 풀에 자금 저장 (수익 분배 시 자동 호출)\n    function depositReserve(uint256 amount) external;\n\n    // 손실 보전 실행 (Admin 또는 InsuranceManager만 호출 가능)\n    function coverLoss(address recipient, uint256 amount) external onlyRole(INSURANCE_ROLE);\n    \n    // 비상 인출 (Governance 다중 서명 필요)\n    function emergencyWithdraw(address to, uint256 amount) external onlyRole(DEFAULT_ADMIN_ROLE);\n}\n```\n\n### 4.2 수익 배분 로직 수정 (In YieldDistributor)\n기존 `YieldDistributor`에 리저브 적립 로직을 추가해야 합니다.\n```solidity\nfunction distributeYield() external {\n    uint256 totalYield = ...;\n    uint256 reserveAmount = (totalYield * RESERVE_RATE) / 100; // 예: 10%\n    uint256 distributableAmount = totalYield - reserveAmount;\n\n    // 리저브 풀로 송금\n    usdc.transfer(address(reservePool), reserveAmount);\n    reservePool.depositReserve(reserveAmount);\n\n    // 나머지 투자자 분배\n    ...\n}\n```\n\n## 5. 단계별 구현 (Implementation Strategy)\n\n### Phase 1: 기본 적립 (Accumulation)\n*   [ ] `ReservePool.sol` 컨트랙트 구현 및 배포.\n*   [ ] `YieldDistributor`에 `ReservePool` 주소 등록 및 적립 로직(`RESERVE_RATE`) 추가.\n\n### Phase 2: 수동 보상 (Manual Cover)\n*   [ ] 디폴트 발생 시 Admin이 수동으로 `coverLoss`를 호출하여 피해 투자자들에게 에어드랍하는 기능.\n\n### Phase 3: 자동화 및 보험 청구 (Automated Claim)\n*   [ ] 사용자가 자신의 파산한 채권 토큰(`BondToken`)을 소각(Burn)하고, 리저브 풀에서 보상금을 `Claim`하는 기능 구현.\n\n## 6. 결론\n리스크 관리 시스템은 BuildCTC의 지속 가능성을 담보하는 최후의 보루입니다. 초기에는 단순한 적립 모델로 시작하여, 향후 정교한 보험수리적 모델과 거버넌스를 통한 통제를 도입할 것입니다.\n"
  },
  {
    "source": "roadmap/18_ai_guide_assistant_spec.md",
    "content": "# 18. AI Guide Assistant Integration Plan\n\n## 1. 개요 (Overview)\n**AI Guide Assistant**는 BondBase 플랫폼 내에 대화형 AI 인터페이스를 탑재하여, Web3 및 RWA 투자에 익숙하지 않은 사용자들이 쉽고 빠르게 서비스 사용법을 익힐 수 있도록 돕는 온보딩(Onboarding) 솔루션입니다.\n\n## 2. 목표 (Key Objectives)\n*   **진입 장벽 최소화**: \"지갑 연결은 어떻게 하나요?\", \"투자는 어떻게 하나요?\" 등 초보적인 질문에 실시간으로 즉답 제공.\n*   **운영 효율화**: 반복되는 문의를 AI가 자동 처리하여 운영팀의 리소스 절감.\n*   **차별화된 UX**: 정적인 매뉴얼 대신 능동적인 AI 컨시어지 경험을 제공하여 아이디어톤 심사 시 기술적/사용성 측면의 가산점 확보.\n\n---\n\n## 3. 기능 명세 (Feature Specification)\n\n### 3.1 UI/UX\n*   **진입점 (Entry Point)**: 사이드바(Sidebar) 메뉴에 **[AI Guide]** 탭 추가.\n*   **인터페이스**: 카카오톡이나 ChatGPT와 유사한 **채팅(Chat)** 형태.\n*   **주요 기능**:\n    *   **Q&A**: 사용자가 자연어로 질문하면 AI가 답변.\n    *   **Quick Action**: 자주 묻는 질문(FAQ)을 버튼 형태로 제공 (예: \"가스비 받는 법\", \"투자 방법\").\n    *   **Direct Link**: 답변 내에 관련 페이지(예: 설정 페이지, 채권 마켓)로 바로 이동하는 링크 제공.\n\n### 3.2 제공 콘텐츠 (Knowledge Base)\n기존에 작성된 `user-testing-guide.md` 및 `yield-operation-guide.md`를 기반으로 답변을 구성합니다.\n*   MetaMask 설치 및 네트워크 설정법\n*   Creditcoin Testnet Faucet 사용법\n*   MockUSDC 수령 방법\n*   채권 구매 및 Reinvest(재투자) 절차 안내\n\n---\n\n## 4. 기술 구현 전략 (Technical Architecture)\n\nVercel AI SDK를 활용하여 최신 LLM(OpenAI, Gemini)을 즉시 통합합니다. 별도의 벡터 DB 구축 없이 핵심 가이드 문서를 System Prompt에 주입(Context Injection)하여 정확도를 확보합니다.\n\n### 4.1 기술 스택 (Tech Stack)\n*   **Core Library**: `ai` (Vercel AI SDK) - React `useChat` hook 및 스트리밍 처리.\n*   **Providers**: \n    *   `@ai-sdk/openai`: OpenAI (GPT-4o / GPT-3.5-turbo)\n    *   `@ai-sdk/google`: Google (Gemini 1.5 Pro / Flash)\n*   **Framework**: React Router v7 (Resource Route / Action 기반 API 처리)\n\n### 4.2 구현 상세 (Implementation Details)\n\n#### A. 환경 설정 (Environment Setup)\n`.env.local`을 통해 API Key를 관리합니다.\n```env\nOPENAI_API_KEY=sk-...\nGOOGLE_GENERATIVE_AI_API_KEY=AIzaSy...\n```\n\n#### B. 데이터 주입 전략 (Context Injection Strategy)\n벡터 DB(RAG)를 통한 부분 검색 방식 대신, **Direct Context Injection (Full-Text Injection)** 방식을 채택합니다. 마크다운 문서(`docs/**/*.md`)의 전체 내용을 추출하여 **System Prompt**에 직접 주입합니다.\n\n*   **빌드 타임 통합 (Build-time Knowledge Bundling)**: 배포 환경(Vercel 서버리스 등)의 파일 시스템 접근 제한 문제를 해결하기 위해, 빌드 시점에 모든 지식을 통합합니다.\n    *   **자동화 스크립트**: `frontend/scripts/generate-knowledge.cjs`가 `docs/` 내의 모든 마크다운을 스캔하여 하나의 `knowledge.json`으로 합칩니다.\n    *   **프로세스 내재화**: `package.json`의 빌드 명령에 스크립트를 통합하여, 배포 전 항상 최신 문서를 코드로 변환(Bundling)하도록 자동화했습니다.\n*   **Context Injection의 이점**:\n    *   **정확도 극대화**: AI가 문서의 파편화된 조각이 아닌 전체 맥락(Context)을 파악하여 답변하므로 오답률이 현저히 낮습니다.\n    *   **배포 안정성**: 서버리스 환경의 파일 경로 인식 및 권한 문제로부터 100% 설계적 자유를 확보하며 로컬과 실서버 간 데이터 일관성을 보장합니다.\n    *   **실시간 반영**: 별도의 벡터 데이터 가공(Embedding)이나 DB 동기화 없이, 빌드 프로세스만으로 최신 지식이 AI의 '코드 몸체'에 즉시 반영됩니다.\n    *   **효율성**: 현재 프로젝트 규모에서는 최신 LLM의 광대한 Context Window를 활용하는 것이 인프라 복잡도를 줄이는 가장 스마트한 선택입니다.\n\n*   **System Prompt 구성**:\n    > \"너는 BondBase의 AI Concierge야. 아래 제공된 [Master Documents] 내용을 기반으로 기술적 세부사항(컨트랙트 주소, 체인 ID 등)을 인용하여 답변해. 문서에 없는 내용은 모른다고 답하고 지어내지 마.\"\n\n#### C. 모델 선택 (Model Selection)\n*   **Default**: Google `gemini-2.0-flash-exp` (최신 Long Context 모델, 빠른 응답 속도 및 높은 한국어 처리 능력)\n*   **Alternative**: OpenAI `gpt-4o` (복잡한 기술적 추론 시 활용)\n*   **Streaming Control**: Vercel AI SDK의 `smoothStream()` 및 `experimental_transform`을 사용하여 한 글자씩 부드럽게 나타나는 타이핑 효과를 구현합니다.\n\n---\n\n## 5. 실행 계획 (Action Plan)\n\n1.  **UI 구현**:\n    *   `/ai-guide` 라우트 생성.\n    *   `Sidebar`에 메뉴 아이콘(Robot/Chat) 추가.\n    *   ShadCN UI를 활용한 채팅방 컴포넌트 (`Bubble`, `Input`, `ScrollArea`) 개발.\n2.  **데이터 구성**:\n    *   `user-testing-guide.md`의 내용을 Q&A 형식(JSON)으로 변환.\n3.  **로직 구현**:\n    *   간단한 키워드 매칭 로직으로 사용자의 질문 의도 파악 및 답변 출력.\n\n---\n\n## 6. 기대 효과\n이 기능이 구현되면 심사위원들에게 **\"BondBase는 블록체인의 복잡성을 AI 기술로 해결하여 대중성(Mass Adoption)을 확보한 플랫폼\"**이라는 강력한 인상을 줄 수 있습니다.\n"
  },
  {
    "source": "roadmap/IMPLEMENTATION_PLAN.md",
    "content": "# BuildCTC 개발 구현 계획서\n\n## 1. 프로젝트 구조\n\n```\nBuildCTC/\n├── contracts/                    # Solidity 스마트 컨트랙트\n│   ├── BondToken.sol            # ERC-1155 채권 토큰화 컨트랙트\n│   ├── LiquidityPool.sol        # 유동성 풀 관리 컨트랙트\n│   ├── YieldDistributor.sol     # 수익 배분 로직 컨트랙트\n│   ├── ReservePool.sol          # 리저브 풀 관리 컨트랙트 (예정)\n│   ├── OracleAdapter.sol        # Creditcoin Universal Oracle 연동 (예정)\n│   ├── interfaces/              # 인터페이스 정의\n│   └── libraries/               # 라이브러리 (SafeMath 등)\n├── backend/                     # 백엔드 서비스 (Smart Contract 중심 구조로 대체 가능성 있음)\n│   ├── api/                     # REST API 엔드포인트\n│   │   ├── routes/\n│   │   └── middleware/\n│   ├── services/                # 비즈니스 로직\n│   └── config/                  # 설정 파일\n├── frontend/                    # 프론트엔드 애플리케이션\n│   ├── app/                     # React Router v7 App Directory\n│   │   ├── routes/              # 페이지 라우트\n│   │   │   ├── _index.tsx       # 홈 (대시보드)\n│   │   │   ├── bonds.tsx        # 채권 마켓\n│   │   │   ├── portfolio.tsx    # 포트폴리오\n│   │   │   └── settings.tsx     # 설정\n│   │   ├── components/          # UI 컴포넌트\n│   │   │   ├── bonds/           # 채권 관련\n│   │   │   ├── portfolio/       # 포트폴리오 차트 등\n│   │   │   └── settings/        # 설정 폼\n│   │   ├── config/              # 설정 (contracts.ts 등)\n│   │   └── lib/                 # 유틸리티\n│   └── public/\n├── scripts/                     # 유틸리티 스크립트\n│   ├── deploy.ts                # 배포 스크립트\n│   └── deploy_all.ts            # 전체 배포 스크립트\n└── docs/                        # 문서\n    ├── core/                    # 핵심 설계 문서\n    ├── reports/                 # 진행 상황 리포트\n    └── roadmap/                 # 로드맵\n```\n\n## 2. 기술 스택 (Updated)\n\n### 2.1 스마트 컨트랙트\n- **언어**: Solidity ^0.8.20 (EVM Version: `paris`)\n- **프레임워크**: Hardhat\n- **테스트**: Hardhat Test (Mocha/Chai)\n- **배포**: Hardhat Scripts\n- **네트워크**: Creditcoin Testnet (Chain ID: 102031) (EVM 호환)\n- **표준**: \n  - ERC-1155 (BondToken)\n  - ERC-20 (MockUSDC)\n  - OpenZeppelin AccessControl, ReentrancyGuard\n\n### 2.2 백엔드 (Optional/Hybrid)\n- **런타임**: Node.js 18+\n- **데이터베이스**: Turso (SQLite) - 사용자 프로필 등 오프체인 데이터\n- **ORM**: Drizzle ORM\n- **인증**: Better Auth (Cookie Session) + Wallet Auth (SIWE 예정)\n\n### 2.3 프론트엔드\n- **프레임워크**: React Router v7 (Vite)\n- **상태 관리**: @tanstack/react-query (Server State), Local State\n- **스타일링**: Tailwind CSS v3.4, shadcn/ui\n- **Web3 연동**: \n  - **wagmi**: React Hooks for Ethereum\n  - **viem**: Low-level Interface\n- **차트**: Recharts\n- **지도**: Google Maps API (예정)\n- **날짜/시간**: Luxon\n\n## 3. 스마트 컨트랙트 설계 (Current Status)\n\n### 3.1 BondToken.sol (Deployed)\n- **Address**: `frontend/app/config/contracts.ts` 참조\n- **기능**: ERC-1155 기반, `RoleBased` AccessControl, 동적 URI 설정.\n\n### 3.2 LiquidityPool.sol (Deployed)\n- **Address**: `frontend/app/config/contracts.ts` 참조\n- **기능**: USDC 예치(Deposit), 채권 구매(Invest), 관리자 인출.\n\n### 3.3 YieldDistributor.sol (Deployed)\n- **Address**: `frontend/app/config/contracts.ts` 참조\n- **기능**: Synthetix 스타일 `RewardPerToken` 알고리즘 기반 수익 배분.\n\n### 3.4 MockUSDC.sol (Deployed)\n- **Address**: `frontend/app/config/contracts.ts` 참조\n- **기능**: 테스트용 ERC-20 토큰 (Faucet 기능 포함).\n\n## 4. 프론트엔드 구현 상태\n- **대시보드**: `/` (기본 레이아웃 및 요약 정보)\n- **채권 마켓**: `/bonds` (필터링, 검색, 모달을 통한 투자 UX)\n- **포트폴리오**: `/portfolio` (자산 현황 차트, 투자 리스트)\n- **설정**: `/settings` (프로필, 지갑 관리 UI)\n\n## 8. 개발 단계별 계획 (Progress Tracker)\n\n### Phase 1: 기초 인프라 (완료)\n- [x] **프로젝트 설정**\n   - [x] Hardhat 프로젝트 초기화 (`evmVersion: paris` 설정)\n   - [x] React Router v7 프론트엔드 스캐폴딩\n   - [x] Tailwind CSS & shadcn/ui 설정\n   - [x] 문서 구조화 (`docs/`)\n\n- [x] **스마트 컨트랙트 기본 구조**\n   - [x] BondToken.sol 구현 (ERC-1155)\n   - [x] MockUSDC.sol 구현 (ERC-20)\n   - [x] 단위 테스트 작성 (BondToken)\n\n- [x] **로컬 개발 환경 & 배포**\n   - [x] Hardhat 로컬 네트워크 테스트\n   - [x] Creditcoin Testnet 배포 스크립트 작성 (`deploy_all.ts`)\n   - [x] Testnet 배포 완료 및 주소 확보\n\n### Phase 2: 핵심 기능 (진행 중)\n- [x] **유동성 풀 구현**\n   - [x] LiquidityPool.sol 완성\n   - [x] 예치/인출 로직 구현\n   - [x] 채권 구매(Invest) 연동 (`purchaseBond`)\n   - [x] AccessControl 권한 설정 (Mininter Role)\n\n- [x] **수익 배분 시스템**\n   - [x] YieldDistributor.sol 구현\n   - [x] `rewardPerToken` 기반 수익 계산 로직\n   - [x] Staking(예치) 및 Claim(수령) 로직\n   - [x] 단위 테스트 통과\n\n- [x] **프론트엔드-블록체인 연동** (부분 완료, 버그 수정 필요)\n   - [x] `purchaseBond` 함수 호출 구현 ✅\n   - [x] `claimYield`, `reinvest` 함수 호출 구현 ✅\n   - [x] `balanceOfBatch` 데이터 조회 구현 ✅\n   - [ ] `portfolio.tsx` 버그 수정 (bondId 파라미터 누락) ⚠️\n\n- [ ] **오라클 연동** (다음 마일스톤)\n   - [ ] Phase 1: MockOracle.sol 구현\n   - [ ] Phase 2: OracleAdapter.sol 구현\n   - [ ] Phase 3: 백엔드 오라클 서비스 구성\n   - [ ] Creditcoin Universal Oracle 연동\n\n### Phase 3: 리스크 관리 (예정)\n- [ ] **리저브 풀**\n   - [ ] ReservePool.sol 구현\n   - [ ] 손실 보상 로직\n\n- [ ] **디폴트 처리**\n   - [ ] 디폴트 감지 시스템\n   - [ ] 투자자 알림\n\n### Phase 4: UI/UX (부분 완료)\n- [x] **투자자 대시보드**\n   - [x] 기본 레이아웃 (Sidebar, Header)\n   - [x] 채권 목록 및 상세 모달 (Bond Market)\n   - [x] 포트폴리오 페이지 (Chart, List)\n   - [x] 설정 페이지 (Profile, Wallet UI)\n\n- [x] **Web3 연동** (완료, 일부 버그 존재)\n   - [x] `wagmi` / `viem` 설정\n   - [x] 지갑 연결 (Connect Wallet) 기능 구현\n   - [x] 컨트랙트 데이터 바인딩 (Balance, Invest, Claim)\n   - [x] `purchaseBond`, `claimYield`, `reinvest` 실제 호출 구현\n   - [ ] `portfolio.tsx` 버그 수정 필요 (Section 9.2 참조)\n\n- [ ] **임팩트 시각화**\n   - [ ] 지도 통합\n   - [ ] ESG 지표 시각화\n\n### Phase 5 ~ 6 (이후 계획)\n- [ ] Gateway 통합 (Cross-chain)\n- [ ] 보안 감사 및 최적화\n- [ ] 메인넷 배포 준비\n\n## 9. 현재 프로젝트 상태 및 알려진 이슈 (Latest Review: 2026-01-16)\n\n> **참고**: 전체 검토 내용은 `docs/reports/18_project_review_report.md`를 참조하세요.\n\n### 9.1 현재 진행 상태 요약\n\n#### 완료된 주요 기능 ✅\n- [x] 스마트 컨트랙트 개발 및 배포 (Creditcoin Testnet)\n  - MockUSDC, BondToken (v2), LiquidityPool, YieldDistributor (v2)\n- [x] 프론트엔드 기본 구조 및 UI 컴포넌트\n- [x] Web3 연동 (`wagmi`/`viem`) - 지갑 연결, 컨트랙트 호출 구현\n- [x] 데이터베이스 스키마 설계 (Drizzle ORM)\n\n#### 진행 중 🚧\n- [ ] 프론트엔드-블록체인 연동 (부분 완료, 버그 수정 필요)\n- [ ] 오라클 연동 (설계 완료, 구현 대기)\n- [ ] 백엔드 API 개발 (미시작)\n\n#### 미시작 ❌\n- [ ] 리저브 풀 구현\n- [ ] Gateway 통합 (크로스체인)\n- [ ] KYC/AML 시스템\n- [ ] 보안 감사\n\n### 9.2 알려진 버그 및 이슈\n\n#### Critical (즉시 수정 필요) ⚠️\n1. **프론트엔드 버그**\n   - `portfolio.tsx`의 `earned` 함수 호출 시 `bondId` 파라미터 누락\n     - 컨트랙트 시그니처: `earned(address account, uint256 bondId)`\n     - 현재: `args: [address]`만 전달\n   - `portfolio.tsx`의 `claimYield` 호출 시 `bondId` 파라미터 누락\n     - 컨트랙트 시그니처: `claimYield(uint256 bondId)`\n     - 현재: `args` 없이 호출\n\n#### High Priority\n2. **테스트 스크립트 미설정**\n   - `contracts/package.json`에 `\"test\": \"hardhat test\"` 스크립트 추가 필요\n\n3. **환경 변수 보안 검증**\n   - `.env*` 파일이 Git에 커밋되지 않았는지 확인 필요\n   - `git log --all --full-history -- \"*.env*\"` 명령어로 검증 권장\n\n### 9.3 즉시 조치 사항\n\n#### Critical (즉시 처리)\n1. [ ] 프론트엔드 버그 수정 (`portfolio.tsx`의 `earned`, `claimYield` 호출)\n2. [ ] 테스트 스크립트 추가 (`contracts/package.json`)\n3. [ ] 환경 변수 보안 검증\n\n#### High Priority (1주일 내)\n4. [ ] 오라클 연동 구현 시작 (Phase 1: MockOracle.sol)\n5. [ ] 백엔드 API 기본 구조 구축\n\n### 9.4 기술 부채\n\n1. **Mock 데이터 의존**\n   - 프론트엔드에서 채권 목록 등 Mock 데이터 사용 중\n   - 실제 블록체인 데이터 연동 필요\n\n2. **하드코딩된 컨트랙트 주소**\n   - `frontend/app/config/contracts.ts`에 주소 직접 입력\n   - 네트워크별 동적 설정 개선 필요\n\n3. **타입 안전성 개선**\n   - 프론트엔드에서 컨트랙트 ABI 타입 생성 (`typechain`) 활용 검토\n   - 현재 수동으로 ABI 정의 중\n\n## 10. 보안 및 배포 전략 (Refined)\n\n### 10.1 배포 현황\n- **Network**: Creditcoin Testnet\n- **Deployed Contracts**:\n  - MockUSDC, BondToken, LiquidityPool, YieldDistributor\n- **Configuration**:\n  - Frontend: `frontend/app/config/contracts.ts`에 주소 및 ABI 관리\n\n### 10.2 향후 보안 계획\n- [ ] `dotenv`를 통한 환경 변수 관리 강화 (진행 중)\n- [ ] 배포 전 `slither` 등을 이용한 정적 분석 수행\n- [ ] 주요 권한(Admin Role) 관리자 지갑 분리\n- [ ] 멀티시그 지갑 도입 검토\n\n## 11. 문서화\n- [x] 구현 계획서 (`IMPLEMENTATION_PLAN.md`)\n- [x] 단계별 리포트 (`docs/reports/`)\n  - `docs/reports/18_project_review_report.md`: 프로젝트 종합 검토 보고서 (2026-01-16)\n- [x] 오라클 연동 설계 (`docs/roadmap/14_oracle_integration_architecture.md`)\n- [ ] API 문서 (백엔드 구축 시)\n- [ ] 사용자 가이드 (최종 릴리스 시)\n- [ ] 배포 가이드\n- [ ] 보안 감사 리포트"
  },
  {
    "source": "roadmap/PLAN.md",
    "content": "# BuildCTC 프로젝트 기획서\n\n## 1. 프로젝트 개요\n\n### 1.1 프로젝트 명\n**BuildCTC (Build Creditcoin Tokenized Credit)** - RWA Yield Protocol\n\n### 1.2 프로젝트 목적\n실물 자산(Real World Assets)의 가치를 온체인으로 가져와 투자자에게 수익을 배분하는 탈중앙화 금융(DeFi) 프로토콜 구축\n\n### 1.3 핵심 가치 제안\n- **변동성 방어**: 암호화폐 시장 변동성과 무관한 안정적인 수익 제공\n- **투명성**: Creditcoin 네트워크를 통한 실물 대출 이력의 온체인 기록 및 검증\n- **소셜 임팩트**: 신흥 시장 소상공인에 대한 금융 포용성 제공 및 ESG 투자 유치\n- **크로스체인 접근성**: Creditcoin Gateway를 통한 다양한 체인 투자자 참여\n\n## 2. 비즈니스 모델\n\n### 2.1 수익 구조\n1. **관리 수수료**: 유동성 풀 관리에 대한 연간 수수료 (예: 1-2%)\n2. **성과 수수료**: 수익 배분 시 일정 비율 수수료 (예: 10-20%)\n3. **거래 수수료**: 토큰 거래 시 발생하는 수수료\n\n### 2.2 참여자\n- **투자자 (Investors)**: USDC를 예치하여 수익을 받는 참여자\n- **대출자 (Borrowers)**: 태국 소상공인 등 실물 경제의 대출 수요자\n- **파트너 (Partners)**: 현지 대출 기관 (현재 미확정)\n- **프로토콜 운영자**: 스마트 컨트랙트 관리 및 오라클 연동\n\n## 3. 타겟 시장\n\n### 3.1 초기 시장: 태국\n- **이유**: \n  - 동남아시아 주요 경제국으로 금융 규제 프레임워크가 비교적 명확함\n  - 소상공인 대출 시장이 활발함\n  - 블록체인/크립토 친화적 정책 추진 중\n- **대상 자산**: 태국 소상공인 대출 채권\n- **예상 규모**: 초기 소규모 파일럿 (10-50건의 대출 채권)\n\n### 3.2 확장 계획\n- 동남아시아: 베트남, 인도네시아, 필리핀\n- 아프리카: 케냐, 가나, 나이지리아\n\n## 4. 토큰 모델\n\n### 4.1 ERC-1155 분할 토큰\n- **선택 이유**:\n  - 단일 대출 채권을 여러 투자자에게 분할하여 판매 가능\n  - 유동성 향상 및 진입 장벽 완화\n  - NFT의 고유성과 ERC-20의 대체 가능성 결합\n- **구조**:\n  - 각 대출 채권 = 하나의 Token ID\n  - 각 Token ID는 여러 개의 분할 단위로 나뉨\n  - 투자자는 원하는 수량만큼 구매 가능\n\n### 4.2 토큰 메타데이터\n각 토큰은 다음 정보를 포함:\n- 대출 채권 ID\n- 대출자 정보 (익명화된 형태)\n- 지역 (태국 내 지역)\n- 사업 유형\n- 대출 금액\n- 이자율\n- 만기일\n- 신용도 등급\n- 상환 이력 (Creditcoin 네트워크 링크)\n\n## 5. 리스크 관리\n\n### 5.1 손실 분산 메커니즘\n- **다각화**: 여러 대출 채권에 분산 투자\n- **자동 재분배**: 디폴트 발생 시 해당 채권의 손실을 모든 투자자에게 비례 분산\n- **우선순위 구조**: 필요 시 Senior/Junior 트랜치 구조 도입 검토\n\n### 5.2 리저브 풀 (Reserve Pool)\n- **목적**: 디폴트 손실을 흡수하여 투자자 보호\n- **자금 조성**:\n  - 초기 자본 조달\n  - 수익의 일정 비율 적립 (예: 5-10%)\n  - 추가 기부/투자 유치\n- **운용 규칙**:\n  - 리저브 풀 최소 유지 비율 설정 (예: 총 자산의 5%)\n  - 디폴트 발생 시 리저브 풀에서 우선 보상\n  - 리저브 풀 고갈 시 투자자 손실 분산\n\n### 5.3 신용 리스크 평가\n- Creditcoin 네트워크의 대출 이력 데이터 활용\n- 온체인 신용 점수 시스템 구축\n- 정기적인 채권 상태 모니터링\n\n## 6. 규제 대응\n\n### 6.1 태국 금융 규제\n- **SEC Thailand**: 증권형 토큰 발행 규제 준수\n- **Bank of Thailand**: 외환 규제 및 크로스보더 자금 이동 규제\n- **Digital Asset Act**: 디지털 자산 거래 및 보관 규제\n\n### 6.2 필수 준수 사항\n- **KYC/AML**: 투자자 신원 확인 및 자금 세탁 방지\n- **투자자 보호**: 적절한 리스크 공시 및 투자 한도 설정\n- **세무 신고**: 수익 발생 시 세무 처리 가이드 제공\n- **라이선스**: 필요 시 금융 서비스 라이선스 취득 검토\n\n### 6.3 컴플라이언스 대시보드\n- 투자자별 KYC 상태 표시\n- 규제 준수 현황 모니터링\n- 감사 추적 가능한 거래 기록\n\n## 7. 파트너십 전략\n\n### 7.1 현재 상태\n- **파트너**: 아직 확정되지 않음\n- **필요한 파트너 유형**:\n  - 태국 현지 대출 기관 (MFI, Fintech 등)\n  - 법률 자문사 (규제 대응)\n  - 회계/감사 기관\n  - 크립토 커스터디 서비스\n\n### 7.2 파트너십 우선순위\n1. **Phase 1**: 현지 대출 기관 (자산 공급)\n2. **Phase 2**: 법률 자문사 (규제 대응)\n3. **Phase 3**: 회계/감사 기관 (신뢰성 확보)\n4. **Phase 4**: 기관 투자자 (자금 조달)\n\n## 8. 소셜 임팩트 및 ESG\n\n### 8.1 금융 포용성\n- 신흥 시장 소상공인에 대한 접근 가능한 자금 조달 경로 제공\n- 전통적 금융 시스템에서 배제된 계층 지원\n\n### 8.2 투명성 및 추적성\n- 투자자가 자신의 자금이 어느 지역, 어떤 사업에 투자되었는지 시각적으로 확인 가능\n- 실시간 상환 현황 및 임팩트 지표 제공\n\n### 8.3 ESG 대시보드\n- 지역별 투자 분포\n- 사업 유형별 분포\n- 예상 고용 창출 효과\n- 환경 친화적 사업 비율\n\n## 9. 기술 아키텍처 개요\n\n### 9.1 블록체인 인프라\n- **기본 네트워크**: Creditcoin 2.0 (EVM 호환)\n- **크로스체인**: Creditcoin Gateway (이더리움, 폴리곤 등)\n- **오라클**: Creditcoin Universal Oracle (실물 상환 데이터)\n\n### 9.2 핵심 컴포넌트\n- **스마트 컨트랙트**: Solidity 기반\n  - BondToken (ERC-1155)\n  - LiquidityPool\n  - YieldDistributor\n  - ReservePool\n  - OracleAdapter\n- **백엔드**: 오라클 연동 및 비즈니스 로직\n- **프론트엔드**: 투자자 대시보드, 관리자 패널\n\n## 10. 로드맵 (초기)\n\n### Phase 1: 기초 구축 (3-6개월)\n- 스마트 컨트랙트 개발 및 테스트\n- 기본 유동성 풀 구현\n- 태국 파트너십 탐색\n\n### Phase 2: 파일럿 런칭 (6-9개월)\n- 소규모 파일럿 (10-20건 대출 채권)\n- 오라클 연동 및 수익 배분 시스템\n- 기본 대시보드 구축\n\n### Phase 3: 규제 대응 및 확장 (9-12개월)\n- 규제 준수 시스템 구축\n- Gateway 통합\n- ESG 대시보드 완성\n\n### Phase 4: 상용화 (12개월+)\n- 대규모 자산 토큰화\n- 기관 투자자 유치\n- 추가 시장 진출\n\n## 11. 성공 지표 (KPI)\n\n### 11.1 재무 지표\n- 총 예치 자산 (TVL)\n- 평균 수익률 (APY)\n- 프로토콜 수익\n\n### 11.2 운영 지표\n- 토큰화된 대출 채권 수\n- 활성 투자자 수\n- 평균 투자 금액\n\n### 11.3 리스크 지표\n- 디폴트율\n- 리저브 풀 비율\n- 신용 점수 분포\n\n## 12. 리스크 및 과제\n\n### 12.1 기술적 리스크\n- 오라클 데이터 정확성\n- 스마트 컨트랙트 보안\n- 크로스체인 브릿지 리스크\n\n### 12.2 비즈니스 리스크\n- 파트너십 확보 지연\n- 규제 변화\n- 시장 수요 부족\n\n### 12.3 운영 리스크\n- 디폴트율 증가\n- 리저브 풀 고갈\n- 유동성 부족\n\n## 13. 다음 단계\n\n1. **파트너십 탐색**: 태국 현지 대출 기관 접촉\n2. **법률 자문**: 태국 금융 규제 전문가 컨설팅\n3. **기술 검증**: Creditcoin 네트워크 및 오라클 기능 테스트\n4. **프로토타입 개발**: MVP 스마트 컨트랙트 및 대시보드\n"
  },
  {
    "source": "stitch/design-brief.md",
    "content": "# BuildCTC Project Design Brief\n\n## 1. 프로젝트 개요 (Project Overview)\n- **프로젝트명**: BuildCTC (RWA Yield Protocol)\n- **핵심 가치**: 신흥 시장(태국 등)의 실물 대출 채권을 토큰화하여 투자자에게 안정적인 수익(Yield)을 제공하고, 소상공인에게는 금융 접근성을 제공하는 RWA(Real World Assets) 프로토콜.\n- **기반 기술**: Creditcoin 2.0 (EVM Compatible) 및 Creditcoin Gateway 활용.\n\n## 2. 디자인 목표 (Design Goals)\n- **신뢰성 (Reliability)**: 실물 금융 자산을 다루는 서비스로서 견고하고 전문적인 금융 UI 제공.\n- **접근성 (Accessibility)**: 복잡한 블록체인 개념을 제외하고 일반 사용자도 쉽게 투자할 수 있는 직관적인 UX.\n- **투명성 (Transparency)**: 실물 데이터(상환 이력, 지역별 지원 현황)를 시각적으로 명확하게 전달.\n\n## 3. 타겟 사용자 (Target Audience)\n- **개인 투자자**: 안정적인 APY를 추구하는 글로벌 DeFi 투자자 및 일반인.\n- **기관 투자자**: ESG 지표 및 투명한 자산 관리를 중시하는 투자자.\n- **현지 파트너**: 실물 자산 데이터 및 대출 상태를 모니터링하는 운영진.\n\n## 4. 필수 화면 구성 (Core Screens)\n\n### 4.1 랜딩 페이지 (Landing Page)\n- 서비스 아이덴티티 및 핵심 가치 제안.\n- 실시간 TVL(Total Value Locked), 활성 투자자 수, 누적 지급 수익 등 요약 표시.\n- \"최초의 실물 기반 안정적 수익\"을 강조하는 프리미엄 비주얼.\n\n### 4.2 투자 대시보드 (Investment Dashboard)\n- **채권 리스팅**: 현재 투자 가능한 대출 채권 목록 (신용 등급, 이자율, 만기일 등 필터링 포함).\n- **채권 상세**: 채권의 구체적인 명세, 대출자 사업 유형, 지역 정보, Creditcoin 기반 상환 데이터 링크.\n- **투자 실행 UI**: 원하는 수량 구매 및 EVM 기반 지갑(MetaMask 등) 연동 프로세스.\n\n### 4.3 포트폴리오 및 수익 관리 (Portfolio & Yield)\n- 내 총 투자 금액, 보유 채권 목록, 누적 수익금 요약.\n- **수익 청구(Claim)**: 발생한 수익을 인출하거나 재투자하는 기능.\n- 투자 자산의 상태(상환 중, 상환 완료, 디폴트 위험 등) 표시.\n\n### 4.4 임팩트 맵 및 ESG 대시보드 (Impact Map & ESG)\n- **지도 시각화**: 태국 등 현지 소상공인에게 자금이 전달된 위치 표시 (Heatmap 또는 Cluster).\n- **ESG 지표**: 지원 사업 유형 분포(F&B, 서비스 등), 신규 고용 창출 효과 등 시각 차트.\n\n### 4.5 지갑 연동 및 온보딩 (Wallet & Onboarding)\n- **EVM 지갑 연동**: MetaMask, WalletConnect 등을 통한 간편한 지갑 연결.\n- **크로스체인 투자**: Creditcoin Gateway를 활용하여 타 체인(Ethereum, Polygon 등) 자산으로 참여하는 UX 가이드.\n\n## 5. 디자인 가이드라인 (Tone & Manner)\n- **컬러 팔레트**: 신뢰를 주는 딥 네이비 또는 다크 그린 계열 + 블록체인의 역동성을 나타내는 비비드한 블루/퍼플 포인트.\n- **타이포그래피**: 가독성이 우수한 산세리프 글꼴 (Inter, Outfit 등 추천).\n- **컴포넌트**: shadcn/ui 스타일의 깔끔하고 모던한 UI 라이브러리 기반.\n- **모드**: 다크 모드를 기본으로 하되 정교한 라이트 모드 테마 포함.\n\n## 6. 요청 사항 (Deliverables)\n- 주요 5개 화면에 대한 고해상도 디자인 (Figma).\n- 반응형(Desktop & Mobile) 대응 레이아웃.\n- 주요 인터랙션(투자 성공, 에러 토스트, 로딩 애니메이션) 가이드.\n\n---\n*본 의뢰서는 `docs/PLAN.md` 및 `docs/IMPLEMENTATION_PLAN.md`를 바탕으로 작성되었습니다.*\n"
  },
  {
    "source": "stitch/design-resources.md",
    "content": "# Design Resources & Links\n\n## 1. Stitch Project (Main Design Samples)\n- **URL**: [Stitch Project URL](https://stitch.withgoogle.com/projects/17193233867447468760)\n- **Description**: Stitch 팀에서 제작한 BuildCTC 프로젝트 디자인 샘플 및 프로토타입. UI/UX 구현 시 최우선으로 참조되는 디자인 가이드라인.\n- **Added Date**: 2026-01-15\n\n## 2. Usage Strategy for AI Agent\n- **Component Development**: Tailwind CSS 및 shadcn/ui 컴포넌트 개발 시 위 URL의 시각적 요소(색상, 간격, 타이포그래피)를 반영함.\n- **Layout Reference**: 각 화면(Dashboard, Profile, Impact Map 등)의 레이아웃 및 내비게이션 구조를 참조함.\n- **Interaction Proofing**: 버튼 호버 효과, 상태 변화(Loading/Success), 트랜잭션 진행 표시 등의 인터랙션을 확인하는 용도로 사용함.\n"
  }
]